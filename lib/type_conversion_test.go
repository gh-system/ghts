package lib

import (
	"math/big"
	"testing"
	"time"
)

func TestS바이트_변환_매개체(t *testing.T) {
	t.Parallel()

	변환형식_모음 := f테스트용_변환형식_모음()
	값_모음 := f테스트용_변환가능한_전달값_모음()

	바이트_변환_매개체, 에러 := New바이트_변환(P변환형식_기본값, 1000)
	F테스트_에러없음(t, 에러)
	값_모음 = append(값_모음, 바이트_변환_매개체)

	for _, 변환형식 := range 변환형식_모음 {
		for _, 값 := range 값_모음 {
			바이트_변환_매개체1, 에러 := New바이트_변환(변환형식, 값)
			F테스트_에러없음(t, 에러)

			원래값_바이트_변환값_비교(t, 값, 바이트_변환_매개체1)

			바이트_모음, 에러 := 바이트_변환_매개체1.MarshalBinary()
			F테스트_에러없음(t, 에러)

			바이트_변환_매개체2 := new(S바이트_변환)
			에러 = 바이트_변환_매개체2.UnmarshalBinary(바이트_모음)
			F테스트_에러없음(t, 에러)

			원래값_바이트_변환값_비교(t, 값, 바이트_변환_매개체2)
		}
	}
}

func TestS바이트_변환_매개체_모음(t *testing.T) {
	t.Parallel()

	변환형식_모음 := f테스트용_변환형식_모음()
	//값_모음 := f테스트용_변환가능한_전달값_모음()
	값_모음 := []interface{}{100, "문자열"}

	for _, 변환형식 := range 변환형식_모음 {
		바이트_변환_매개체, 에러 := New바이트_변환_모음(변환형식, 값_모음...)
		F테스트_에러없음(t, 에러)

		바이트_모음, 에러 := 바이트_변환_매개체.MarshalBinary()
		F테스트_에러없음(t, 에러)

		바이트_변환_매개체2 := new(S바이트_변환_모음)
		에러 = 바이트_변환_매개체2.UnmarshalBinary(바이트_모음)
		F테스트_에러없음(t, 에러)

		for i := 0; i < 바이트_변환_매개체2.G수량(); i++ {
			원래값_바이트_변환값_비교(t, 값_모음[i], 바이트_변환_매개체2.M바이트_변환_모음[i])
		}
	}
}

func 원래값_바이트_변환값_비교(t *testing.T, 원래값 interface{}, 바이트_전송값 *S바이트_변환) {
	var 에러 error = nil

	switch 원래값.(type) {
	case nil:
		복원값 := interface{}(nil)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		// 값은 nil이지만, 자료형은 nil이 아님.
		// 진짜 nil을 전달받는 방법은 모르겠음.
		F테스트_참임(t, 바이트_전송값.IsNil())
		F테스트_참임(t, 복원값 == nil)
	case int:
		복원값 := 0
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uint:
		복원값 := uint(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uintptr:
		복원값 := uintptr(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case int8:
		복원값 := int8(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case int16:
		복원값 := int16(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case int32:
		복원값 := int32(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case int64:
		복원값 := int64(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uint8:
		복원값 := uint8(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uint16:
		복원값 := uint16(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uint32:
		복원값 := uint32(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case uint64:
		복원값 := uint64(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case float32:
		복원값 := float32(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case float64:
		복원값 := float64(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case bool:
		복원값 := true
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case string:
		복원값 := ""
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case []byte:
		var 복원값 []byte
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case error:
		var 복원값 error
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case time.Time:
		복원값 := time.Time{}
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case []string:
		var 복원값 []string
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case s샘플_구조체_1:
		복원값 := s샘플_구조체_1{}
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *s샘플_구조체_1:
		복원값 := new(s샘플_구조체_1)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case s샘플_구조체_2:
		복원값 := s샘플_구조체_2{}
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *s샘플_구조체_2:
		복원값 := new(s샘플_구조체_2)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *big.Int:
		복원값 := big.NewInt(0)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *big.Rat:
		복원값 := big.NewRat(1, 1)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *big.Float:
		복원값 := new(big.Float)
		에러 = 바이트_전송값.G값(&복원값)
		F테스트_에러없음(t, 에러)
		F테스트_같음(t, 원래값, 복원값)
	case *S바이트_변환:
		F테스트_같음(t, 원래값, 바이트_전송값)
	default:
		New에러with출력("예상치 못한 자료형. %T", 원래값)
		t.FailNow()
	}
}

func TestS바이트_변환_S질의값_바이트_변환(t *testing.T) {
	지금 := time.Now()
	값1 := New질의값_바이트_변환(TR구분(20), "test", 지금)

	바이트_변환_모음 := F확인2(New바이트_변환(P변환형식_기본값, 값1))
	값2 := F확인2(바이트_변환_모음.G해석값()).(*S질의값_바이트_변환)

	F테스트_같음(t, 값1.M구분, 값2.M구분)
	F테스트_같음(t, 값1.M코드, 값2.M코드)

	지금_복원값 := F확인2(값2.M바이트_변환.G해석값()).(time.Time)
	F테스트_참임(t, 지금_복원값.Equal(지금), 지금_복원값, 지금)
}

func TestS바이트_변환_S질의값_바이트_변환_모음(t *testing.T) {
	지금 := time.Now()
	내일 := 지금.AddDate(0, 0, 1)
	값1 := New질의값_바이트_변환_모음(TR구분(20), "test", 지금, 내일)

	바이트_변환_모음 := F확인2(New바이트_변환_모음(P변환형식_기본값, 값1))
	값2 := F확인2(바이트_변환_모음.G해석값(0)).(*S질의값_바이트_변환_모음)

	F테스트_같음(t, 값1.M구분, 값2.M구분)
	F테스트_같음(t, 값1.M코드, 값2.M코드)

	지금_복원값 := F확인2(값2.M바이트_변환_모음.G해석값(0)).(time.Time)
	F테스트_참임(t, 지금_복원값.Equal(지금), 지금_복원값, 지금)

	내일_복원값 := F확인2(값2.M바이트_변환_모음.G해석값(1)).(time.Time)
	F테스트_참임(t, 내일_복원값.Equal(내일), 내일_복원값, 내일)
}
