package bt

import (
	bfc "github.com/ghts/ghts/backtest/factor/common"
	"github.com/ghts/ghts/lib"
)

func F백테스트_실행[T팩터 T팩터_데이터, T재무 T재무_데이터](전략_인수 I전략_인수[T팩터, T재무]) {
	전략_실행기 := New전략_실행기(전략_인수)
	데이터_처리기 := 전략_인수.G데이터_처리기()
	포트폴리오 := 전략_인수.G포트폴리오()

	for _, 일자 := range 데이터_처리기.G영업일_모음() {
		for _, 가격구분 := range []T가격_구분{P시가, P저가, P고가, P종가} {
			데이터_처리기.(I데이터_처리기_백테스트_전용).S준비(일자, 가격구분)
			포트폴리오.(I포트폴리오_백테스트_전용).S준비(일자, 가격구분)
			전략_실행기.G실행()
			포트폴리오.(I포트폴리오_백테스트_전용).S일일_결산()
		}
	}
}

func New전략_인수_세종(전략 func(*S필터_정렬_처리기[*S팩터_세종])) I전략_인수[*S팩터_세종, *bfc.S재무_세종] {
	s := new(S전략_인수[*S팩터_세종, *bfc.S재무_세종])
	s.M전략명 = "백테스트"
	s.M계좌번호 = "없음"
	s.M리밸런싱_주기 = lib.P리밸런싱_주기_분기
	s.M종목_수량 = 20
	s.M복합_등급_계산_함수 = 전략
	s.M급등_종목_제외 = true
	s.M급락_종목_제외 = true
	s.M버퍼_퍼센트 = 30
	s.M데이터_처리기 = new(S데이터_처리기_백테스트)
	s.M팩터_데이터_처리기 = new(S팩터_데이터_처리기[*S팩터_세종, *bfc.S재무_세종])
	s.M포트폴리오 = new(S포트폴리오)

	return s
}

func F점수_계산_강환국_무작정_따라하기_단순형(s *S필터_정렬_처리기[*S팩터_세종]) {
	// 점수는 최고/최저가 서로 다르지만, 등급은 최저/최고 0~100으로 동일함.
	// 각 팩터별, 카테고리별 동일 비중을 가지고, 과최적화를 피하기 위해서 점수를 바로 사용하지 않고 '등급'을 거쳐서 사용함.
	//
	// 팩터(PSR/PER등) 점수 -> 팩터(PSR/PER등) 등급 -> 카테고리(가치/성장) 점수 -> 카테고리(가치/성장) 등급 -> 복합 점수 -> 복합 등급

	// 시총 하위 20%
	총수량 := s.Len()
	s.S정렬(func(s *S필터_정렬_처리기[*S팩터_세종], i, j int) bool {
		return s.M저장소[i].M시가총액 < s.M저장소[j].M시가총액
	}).S상위_N개(총수량 * 20 / 100) // 시가 총액이 낮은 순서대로 정렬했으므로 상위 N개가 시총 하위 종목임.

	// 가치 점수, 성장성 점수
	for _, 값 := range s.M저장소 {
		값.M가치_점수 = 값.PSR등급 + 값.POR등급 + 값.PER등급 + 값.PBR등급
		값.M성장성_점수 = 값.M매출액_성장율_등급 + 값.M영업이익_성장율_등급 + 값.M당기순이익_성장율_등급
	}

	// 가치 등급
	f등급_세종(func(값 *S팩터_세종) float64 { return 1 / 값.M가치_점수 },
		func(값 *S팩터_세종, 등급 float64) { 값.M가치_등급 = 등급 }, s)

	// 성장성 등급
	f등급_세종(func(값 *S팩터_세종) float64 { return 1 / 값.M성장성_점수 },
		func(값 *S팩터_세종, 등급 float64) { 값.M성장성_등급 = 등급 }, s)

	// 복합 점수.
	for _, 값 := range s.M저장소 {
		값.M복합_점수 = 값.M가치_등급 + 값.M성장성_등급
	}

	// 복합 등급
	f등급_산출(func(값 *S팩터_세종) float64 { return 1 / 값.M복합_점수 },
		func(값 *S팩터_세종, 등급 float64) { 값.M복합_등급 = 등급 }, s)
}
