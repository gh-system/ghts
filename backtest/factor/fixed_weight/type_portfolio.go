package ftfw

import (
	btc "github.com/ghts/ghts/backtest/common"
	"github.com/ghts/ghts/lib"
	"math"
)

type S포트폴리오 struct {
	M일자        uint32
	M가격구분      btc.T가격_구분
	M보유_현황     *S일자별_자산_현황
	M자산_현황_기록  []*S일자별_자산_현황
	M주문_체결_기록  []*S매매
	M리밸런싱_기록   []*S리밸런싱
	M일일_평가액_기록 []*S일일_평가액
	M데이터_처리기   I데이터_처리기
}

func (s *S포트폴리오) S준비(일자 uint32, 가격구분 btc.T가격_구분) {
	s.M일자 = 일자
	s.M가격구분 = 가격구분
	s.M보유_현황.M일자 = 일자
}

func (s *S포트폴리오) G보유_종목_코드_모음() []string {
	return s.M보유_현황.G종목코드_모음()
}

func (s *S포트폴리오) S주문_체결(주문 *S매매) {
	s.M보유_현황.S주문_체결(주문)
	s.M주문_체결_기록 = append(s.M주문_체결_기록, 주문)
}

func (s *S포트폴리오) G리밸런싱_필요(계좌번호 string, 리밸런싱_주기 lib.T리밸런싱_주기) bool {
	if s.M리밸런싱_기록 == nil {
		s.M리밸런싱_기록 = make([]*S리밸런싱, 0)
	}

	if s.M가격구분 != btc.P종가 {
		return false
	} else if len(s.M리밸런싱_기록) == 0 {
		return true
	} else if 최근_리밸런싱_일자 := s.M리밸런싱_기록[len(s.M리밸런싱_기록)-1].M일자; s.M일자%100 == 최근_리밸런싱_일자%100 {
		return false // 해당 월에 이미 리밸런싱 했음.
	}

	switch 리밸런싱_주기 {
	case lib.P리밸런싱_주기_연:
		panic("TODO")
	case lib.P리밸런싱_주기_반기:
		panic("TODO")
	case lib.P리밸런싱_주기_분기:
		return s.g분기_리밸런싱_필요()
	case lib.P리밸런싱_주기_월:
		panic("TODO")
	default:
		panic(lib.New에러("예상하지 못한 리밸런싱 주기값 : '%v'", int(리밸런싱_주기)))
	}
}

// 퀀터스 분기 리밸런싱 일자 기준. (4/15, 6/15, 9/15, 12/15일)
func (s *S포트폴리오) g분기_리밸런싱_필요() bool {
	연 := s.M일자 % 10000
	월 := (s.M일자 - 연*10000) % 100
	일 := s.M일자 - 연*10000 - 월*100

	var 기준일 uint32

	switch 월 {
	case 4, 6, 9, 12:
		기준일 = 15
	default:
		return false
	}

	if 일 >= 기준일 {
		return true
	}

	return false
}

func (s *S포트폴리오) G리밸런싱_기준_가격(종목코드 string) float64 {
	일자 := s.M리밸런싱_기록[len(s.M리밸런싱_기록)-1].M일자
	return s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G가격(일자, btc.P종가, 종목코드) // 리밸런싱은 종가 기준으로 진행했음.
}

func (s *S포트폴리오) G리밸런싱_기준_수량(종목코드 string) int64 {
	return s.M리밸런싱_기록[len(s.M리밸런싱_기록)-1].M주식[종목코드]
}

func (s *S포트폴리오) G보유_수량_맵() (map[string]int64, error) {
	return s.M보유_현황.G복사본().M주식, nil
}

func (s *S포트폴리오) S리밸런싱_실행(종목코드_모음 []string) error {
	if s.M가격구분 != btc.P종가 {
		panic(lib.New에러("예상하지 못한 가격구분 : '%리밸런싱_기록'", s.M가격구분))
	}

	s.M보유_현황.M일자 = s.M일자 // 중복이지만 확실하게 함.

	for 종목코드, 보유_수량 := range s.M보유_현황.M주식 {
		가격 := s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G기준일_시가_종가_평균(s.M일자, 종목코드)
		s.s매도(종목코드, 보유_수량, 가격, P리밸런싱_매도)
	}

	계좌_평가액 := s.M보유_현황.G평가액(s.M가격구분, s.M데이터_처리기)
	종목당_금액 := 계좌_평가액 / float64(len(종목코드_모음))

	리밸런싱_기록 := new(S리밸런싱)
	리밸런싱_기록.M일자 = s.M일자
	리밸런싱_기록.M주식 = make(map[string]int64)

	for _, 종목코드 := range 종목코드_모음 {
		가격 := s.M데이터_처리기.G현재가(종목코드)
		수량 := int64(종목당_금액 / 가격)
		리밸런싱_기록.M주식[종목코드] = 수량

		s.s매수(종목코드, 수량, 가격, P리밸런싱_매수)
	}

	s.M리밸런싱_기록 = append(s.M리밸런싱_기록, 리밸런싱_기록)

	return nil
}

func (s *S포트폴리오) S손절(종목코드 string) {
	수량 := s.M보유_현황.M주식[종목코드]
	가격 := s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G기준일_시가_종가_평균(s.M일자, 종목코드)
	s.s매도(종목코드, 수량, 가격, P손절)
}

func (s *S포트폴리오) S전체_손절() {
	for 종목코드, 수량 := range s.M보유_현황.M주식 {
		가격 := s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G기준일_시가_종가_평균(s.M일자, 종목코드)
		s.s매도(종목코드, 수량, 가격, P전체_손절)
	}
}

func (s *S포트폴리오) S익절(종목코드 string) {
	수량 := s.M보유_현황.M주식[종목코드]
	가격 := s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G기준일_시가_종가_평균(s.M일자, 종목코드)
	s.s매도(종목코드, 수량, 가격, P익절)
}

func (s *S포트폴리오) S부분_익절(종목코드 string, 비율 float64) {
	if 보유_수량, 존재함 := s.M보유_현황.M주식[종목코드]; !존재함 || 보유_수량 <= 0 {
		panic(lib.New에러("부분 익절 대상 종목 미보유 : '%v' '%v' '%v' ", s.M일자, s.M가격구분, 종목코드))
	} else if 기준_수량, 존재함 := s.M리밸런싱_기록[len(s.M리밸런싱_기록)-1].M주식[종목코드]; !존재함 {
		panic(lib.New에러("부분 익절 대상 종목 리밸런싱 기록 없음. : '%v' '%v' '%v' ", s.M일자, s.M가격구분, 종목코드))
	} else if 매도_수량 := float64(기준_수량) * 비율; 매도_수량 > float64(보유_수량)*1.01 { // 1% 이상 오류날 때만 패닉.
		panic(lib.New에러("부분 익절 대상 종목 보유 수량 부족 : '%v' '%v' '%v' '%v' '%v'", s.M일자, s.M가격구분, 종목코드, 보유_수량, 매도_수량))
	} else {
		수량 := lib.F중간값(int64(매도_수량), 0, 보유_수량) // 상한(보유_수량)/하한(0)를 벗어나지 않도록 중간값.
		가격 := s.M데이터_처리기.(I데이터_처리기_백테스트_전용).G기준일_시가_종가_평균(s.M일자, 종목코드)
		s.s매도(종목코드, 수량, 가격, P익절)
	}
}

func (s *S포트폴리오) S일일_결산() {
	if s.M가격구분 != btc.P종가 ||
		s.M자산_현황_기록[len(s.M자산_현황_기록)-1].M일자 >= s.M일자 {
		return
	}

	s.M보유_현황.M일자 = s.M일자 // 중복이지만 일자를 확실하게 설정.
	s.M자산_현황_기록 = append(s.M자산_현황_기록, s.M보유_현황.G복사본())

	일일_평가액 := new(S일일_평가액)
	일일_평가액.M일자 = s.M일자
	일일_평가액.M평가액 = s.M보유_현황.G일일_결산_평가액(s.M데이터_처리기)
	s.M일일_평가액_기록 = append(s.M일일_평가액_기록, 일일_평가액)
}

func (s *S포트폴리오) G투자_성과_계산() (복리_수익율 float64, 최대_낙폭 float64, 샤프_지수 float64) {
	평가액_모음 := make([]float64, len(s.M일일_평가액_기록))

	for i, 값 := range s.M일일_평가액_기록 {
		평가액_모음[i] = 값.M평가액
	}

	초기_투자금 := 평가액_모음[0]
	투자_결과 := 평가액_모음[len(평가액_모음)-1]
	투자_기간 := float64(len(평가액_모음)) / 252.0
	복리_수익율 = math.Pow(math.E, math.Log(투자_결과/초기_투자금)/투자_기간) - 1.0

	최대_낙폭 = 0.0
	전고점 := 평가액_모음[0]
	for _, 평가액 := range 평가액_모음 {
		if 평가액 > 전고점 {
			전고점 = 평가액
		} else if 낙폭 := (전고점 - 평가액) / 전고점; 낙폭 > 최대_낙폭 {
			최대_낙폭 = 낙폭
		}
	}

	수익율_모음 := make([]float64, len(평가액_모음)-1)

	for i := 0; i < len(수익율_모음); i++ {
		수익율_모음[i] = (평가액_모음[i+1] - 평가액_모음[i]) / 평가액_모음[i]
	}

	샤프_지수 = math.Sqrt(252) * lib.F평균(수익율_모음...) / lib.F표준_편차(수익율_모음...)

	return
}

func (s *S포트폴리오) s매도(종목코드 string, 수량 int64, 가격 float64, 매매_상세_구분 T매매_상세_구분) {
	s.s주문(종목코드, lib.P매도, 수량, 가격, 매매_상세_구분)
}

func (s *S포트폴리오) s매수(종목코드 string, 수량 int64, 가격 float64, 매매_상세_구분 T매매_상세_구분) {
	s.s주문(종목코드, lib.P매수, 수량, 가격, 매매_상세_구분)
}

func (s *S포트폴리오) s주문(종목코드 string, 매도_매수_구분 lib.T매도_매수_구분, 수량 int64, 가격 float64, 매매_상세_구분 T매매_상세_구분) {
	if 보유_수량, 존재함 := s.M보유_현황.M주식[종목코드]; 매도_매수_구분 == lib.P매도 && (!존재함 || 보유_수량 <= 0) {
		panic(lib.New에러("미보유 종목 매도 : '%v' '%v' '%v' '%v'", s.M일자, s.M가격구분, 종목코드, 매매_상세_구분))
	} else if 수량 <= 0 {
		panic(lib.New에러("수량 0 : '%v' '%v' '%v' '%v' '%v'", s.M일자, s.M가격구분, 종목코드, 매도_매수_구분, 매매_상세_구분))
	} else if 가격 <= 0 {
		panic(lib.New에러("가격 0 : '%v' '%v' '%v' '%v' '%v'", s.M일자, s.M가격구분, 종목코드, 매도_매수_구분, 매매_상세_구분))
	} else if 매도_매수_구분 != lib.P매도 && 매도_매수_구분 != lib.P매수 {
		panic(lib.New에러("잘못된 매도_매수_구분 값 '%v' : '%v' '%v' '%v' '%v'", 매도_매수_구분, s.M일자, s.M가격구분, 종목코드, 매매_상세_구분))
	} else if 매매_상세_구분 != P리밸런싱_매수 &&
		매매_상세_구분 != P리밸런싱_매도 &&
		매매_상세_구분 != P손절 &&
		매매_상세_구분 != P전체_손절 &&
		매매_상세_구분 != P익절 &&
		매매_상세_구분 != P부분_익절 {
		panic(lib.New에러("잘못된 매매_상세_구분 값 '%v' : '%v' '%v' '%v' '%v'", 매매_상세_구분, s.M일자, s.M가격구분, 종목코드, 매도_매수_구분))
	}

	주문 := new(S매매)
	주문.M종목코드 = 종목코드
	주문.M일자 = s.M일자
	주문.M가격 = 가격
	주문.M매도_매수_구분 = 매도_매수_구분
	주문.M수량 = 수량
	주문.M매매_상세_구분 = 매매_상세_구분

	s.S주문_체결(주문)
}

type S일일_평가액 struct {
	M일자  uint32
	M평가액 float64
}

// 주문 내는 동시에 100% 체결된다고 가정해서 단순화.
type S매매 struct {
	M종목코드     string
	M일자       uint32
	M가격       float64
	M매도_매수_구분 lib.T매도_매수_구분
	M수량       int64
	M매매_상세_구분 T매매_상세_구분
}

func (s S매매) G금액_절대값() float64 {
	return lib.F절대값(s.M가격 * float64(s.M수량))
}

func (s S매매) G금액() float64 {
	return lib.F조건값(s.M매도_매수_구분 == lib.P매도, -1.0, 1.0) * s.G금액_절대값()
}

func (s S매매) G수량_절대값() int64 {
	return lib.F절대값(s.M수량)
}

func (s S매매) G수량() int64 {
	return lib.F조건값[int64](s.M매도_매수_구분 == lib.P매도, -1, 1) * s.G수량_절대값()
}

type S일자별_자산_현황 struct {
	M일자 uint32
	M현금 float64
	M주식 map[string]int64
}

func (s *S일자별_자산_현황) G복사본() *S일자별_자산_현황 {
	v := new(S일자별_자산_현황)
	v.M일자 = s.M일자
	v.M현금 = s.M현금
	v.M주식 = make(map[string]int64)

	for 키, 값 := range s.M주식 {
		v.M주식[키] = 값
	}

	return v
}

func (s *S일자별_자산_현황) S주문_체결(주문_체결 *S매매) {
	if 기존_수량, 존재함 := s.M주식[주문_체결.M종목코드]; !존재함 && (주문_체결.M매도_매수_구분 != lib.P매수 || 주문_체결.G수량() < 0) {
		panic(lib.New에러("보유하지 않는 주식 매도 : %v", 주문_체결))
	} else if !존재함 {
		s.M주식[주문_체결.M종목코드] = 주문_체결.G수량()
	} else if 갱신_수량 := 기존_수량 + 주문_체결.G수량(); 갱신_수량 < 0 {
		panic(lib.New에러("보유 수량보다 더 많은 수량 매도 : %v", 주문_체결))
	} else if 갱신_수량 == 0 {
		delete(s.M주식, 주문_체결.M종목코드)
	} else {
		s.M주식[주문_체결.M종목코드] = 갱신_수량
	}

	s.M현금 -= 주문_체결.G금액() // 주식 매수액과 현금은 반대 관계.

	// 거래비용. (세금(0.3%)/수수료(0.015%)/슬리피지(추산 불가) 등등)
	if 주문_체결.M매도_매수_구분 == lib.P매도 {
		s.M현금 -= 주문_체결.G금액_절대값() * 0.005 // 매도 시 세금 포함 거래비용 0.4% 차감. (세금이 0.3%)
	} else {
		s.M현금 -= 주문_체결.G금액_절대값() * 0.001 // 매수 시 수수료 포함 0.1% 차감
	}

	if s.M현금 < 0 {
		panic(lib.New에러("현금 마이너스 : %v", 주문_체결))
	}
}

func (s *S일자별_자산_현황) G종목코드_모음() (종목코드_모음 []string) {
	종목코드_모음 = make([]string, 0)

	for 종목코드, 보유_수량 := range s.M주식 {
		if 보유_수량 > 0 {
			종목코드_모음 = append(종목코드_모음, 종목코드)
		}
	}

	return 종목코드_모음
}

func (s *S일자별_자산_현황) G평가액(가격구분 btc.T가격_구분, 데이터_처리기 I데이터_처리기) (평가액 float64) {
	가격_맵 := 데이터_처리기.(I데이터_처리기_백테스트_전용).G가격_맵(s.M일자, 가격구분, s.G종목코드_모음())
	평가액 = s.M현금

	for 종목코드, 보유_수량 := range s.M주식 {
		if 보유_수량 <= 0 {
			continue
		} else if 현재가, 존재함 := 가격_맵[종목코드]; 존재함 && 현재가 > 0 {
			평가액 += float64(보유_수량) * 현재가
		}
	}

	return 평가액
}

func (s *S일자별_자산_현황) G일일_결산_평가액(데이터_처리기 I데이터_처리기) (평가액 float64) {
	return s.G평가액(btc.P종가, 데이터_처리기)
}

type S리밸런싱 struct {
	M일자 uint32
	M주식 map[string]int64
}
