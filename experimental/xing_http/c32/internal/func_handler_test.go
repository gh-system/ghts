/* Copyright (C) 2015-2020 김운하 (unha.kim@ghts.org)

이 파일은 GHTS의 일부입니다.

이 프로그램은 자유 소프트웨어입니다.
소프트웨어의 피양도자는 자유 소프트웨어 재단이 공표한 GNU LGPL 2.1판
규정에 따라 프로그램을 개작하거나 재배포할 수 있습니다.

이 프로그램은 유용하게 사용될 수 있으리라는 희망에서 배포되고 있지만,
특정한 목적에 적합하다거나, 이익을 안겨줄 수 있다는 묵시적인 보증을 포함한
어떠한 형태의 보증도 제공하지 않습니다.
보다 자세한 사항에 대해서는 GNU LGPL 2.1판을 참고하시기 바랍니다.
GNU LGPL 2.1판은 이 프로그램과 함께 제공됩니다.
만약, 이 문서가 누락되어 있다면 자유 소프트웨어 재단으로 문의하시기 바랍니다.
(자유 소프트웨어 재단 : Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA)

Copyright (C) 2015-2020년 UnHa Kim (unha.kim@ghts.org)

This file is part of GHTS.

GHTS is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, version 2.1 of the License.

GHTS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with GHTS.  If not, see <http://www.gnu.org/licenses/>. */

package x32

import (
	xing "github.com/ghts/ghts/experimental/xing_http/go"
	"github.com/ghts/ghts/lib"
	krx "github.com/ghts/ghts/lib/krx_time"
	nano "github.com/ghts/ghts/lib/nanomsg"
	xt "github.com/ghts/ghts/xing/base"
	"math"
	"strings"
	"testing"
	"time"
)

var _테스트용_현물_계좌번호_ string

func f테스트용_현물_계좌번호() string {
	if _테스트용_현물_계좌번호_ == "" {
		if 계좌번호_모음, 에러 := xing.F계좌번호_모음(); 에러 == nil {
			_테스트용_현물_계좌번호_ = 계좌번호_모음[0]
		}
	}

	return _테스트용_현물_계좌번호_
}

func TestF접속됨(t *testing.T) {
	t.Parallel()

	접속됨, 에러 := xing.F접속됨()
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 접속됨)
}

func TestF계좌번호_관련_함수(t *testing.T) {
	t.Parallel()

	계좌번호_모음, 에러 := xing.F계좌번호_모음()
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, len(계좌번호_모음) > 0)

	//계좌_상세명, 에러 := xing.F계좌_상세명(계좌번호_모음[0])
	//lib.F테스트_에러없음(t, 에러)
	//lib.F테스트_참임(t, len(strings.TrimSpace(계좌_상세명)) != 0)
}

func TestCSPAQ12200_현물계좌_총평가(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()

	값, 에러 := xing.TrCSPAQ12200_현물계좌_총평가(계좌번호)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_같음(t, 값.M계좌번호, 계좌번호)
	lib.F테스트_다름(t, 값.M계좌명, "")
	//lib.F테스트_참임(t, 값.M현금주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M출금가능금액 >= 0)
	lib.F테스트_참임(t, 값.M코스피_금액 >= 0)
	lib.F테스트_참임(t, 값.M코스닥_금액 >= 0)
	lib.F테스트_참임(t, 값.M잔고평가금액 >= 0)
	lib.F테스트_참임(t, 값.M미수금액 >= 0)
	lib.F테스트_참임(t, 값.M예탁자산총액 >= 0)
	lib.F테스트_참임(t, 값.M투자원금 >= 0)
	lib.F테스트_참임(t, 값.M손익율*float64(값.M투자손익금액) >= 0)
	lib.F테스트_참임(t, 값.M신용담보주문금액 >= 0)
	lib.F테스트_참임(t, 값.M예수금 >= 0, 값.M예수금)
	lib.F테스트_참임(t, 값.D1예수금 >= 0)
	lib.F테스트_참임(t, 값.D2예수금 >= 0)
	lib.F테스트_참임(t, 값.M대용금액 >= 0)
	lib.F테스트_참임(t, 값.M현금미수금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금_현금 >= 0)
	lib.F테스트_참임(t, 값.M증거금_대용 >= 0)
	lib.F테스트_참임(t, 값.M수표_금액 >= 0)
	lib.F테스트_참임(t, 값.M대용주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금률100퍼센트주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금률50퍼센트주문가능금액 >= 값.M증거금률100퍼센트주문가능금액)
	lib.F테스트_참임(t, 값.M증거금률35퍼센트주문가능금액 >= 값.M증거금률50퍼센트주문가능금액)
	lib.F테스트_참임(t, 값.M전일매도정산금액 >= 0)
	lib.F테스트_참임(t, 값.M전일매수정산금액 >= 0)
	lib.F테스트_참임(t, 값.M금일매도정산금액 >= 0)
	lib.F테스트_참임(t, 값.M금일매수정산금액 >= 0)
	lib.F테스트_참임(t, 값.D1연체변제소요금액 >= 0)
	lib.F테스트_참임(t, 값.D2연체변제소요금액 >= 0)
	lib.F테스트_참임(t, 값.D1추정인출가능금액 >= 0)
	lib.F테스트_참임(t, 값.D2추정인출가능금액 >= 0)
	lib.F테스트_참임(t, 값.M예탁담보대출금액 >= 0)
	lib.F테스트_같음(t, 값.M신용설정보증금, 0)
	lib.F테스트_같음(t, 값.M융자금액, 0)
	lib.F테스트_같음(t, 값.M변경후담보비율, 0.0)
	lib.F테스트_같음(t, 값.M담보부족금액, 0)
	lib.F테스트_참임(t, 값.M원담보금액 >= 0)
	lib.F테스트_참임(t, 값.M부담보금액 >= 0)
	lib.F테스트_같음(t, 값.M소요담보금액, 0)
	lib.F테스트_참임(t, 값.M원담보부족금액 >= 0)
	lib.F테스트_같음(t, 값.M소요담보금액, 0)
	lib.F테스트_참임(t, 값.M추가담보현금 >= 0)
	lib.F테스트_참임(t, 값.D1주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M신용이자미납금액 >= 0)
	lib.F테스트_참임(t, 값.M기타대여금액 >= 0)
	lib.F테스트_참임(t, 값.M익일추정반대매매금액 >= 0)
	lib.F테스트_같음(t, 값.M원담보합계금액, 0)
	lib.F테스트_참임(t, 값.M신용주문가능금액 >= 0)
	lib.F테스트_같음(t, 값.M부담보합계금액, 0)
	lib.F테스트_같음(t, 값.M신용담보금현금, 0)
	lib.F테스트_같음(t, 값.M신용담보대용금액, 0)
	lib.F테스트_참임(t, 값.M추가신용담보현금 >= 0)
	lib.F테스트_같음(t, 값.M신용담보재사용금액, 0)
	lib.F테스트_참임(t, 값.M추가신용담보대용 >= 0)
	lib.F테스트_같음(t, 값.M매도대금담보대출금액, 0)
	lib.F테스트_같음(t, 값.M처분제한금액, 0)
}

func TestCSPAQ12300_현물계좌_잔고내역_조회(t *testing.T) {
	t.Parallel()

	const 수량 = 5
	const 가격_정상주문 = int64(0) // 현재가 주문은 가격이 0
	const 호가_유형 = lib.P호가_시장가

	계좌번호 := f테스트용_현물_계좌번호()

	값_모음, 에러 := xing.TrCSPAQ12300_현물계좌_잔고내역_조회(계좌번호, xt.CSPAQ12300_평균_단가, false)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드), 값.M종목코드)
		lib.F테스트_다름(t, 값.M종목명, "")
		lib.F테스트_다름(t, 값.M유가증권잔고유형코드, "")
		lib.F테스트_다름(t, 값.M유가증권잔고유형명, "")
		lib.F테스트_참임(t, 값.M잔고수량 >= 0)
		lib.F테스트_참임(t, 값.M매매기준잔고수량 >= 0)
		lib.F테스트_참임(t, 값.M금일매수체결수량 >= 0)
		lib.F테스트_참임(t, 값.M금일매도체결수량 >= 0)
		lib.F테스트_참임(t, 값.M매도가 >= 0)
		lib.F테스트_참임(t, 값.M매수가 >= 0)

		// 모의투자 세금은 0.25%, 수수료는 0.35% 입니다.
		// 0.6% 로 계산시 해당 값이 나옵니다.
		매도손익금액 := (값.M매도가 - 값.M매수가) * float64(값.M매매기준잔고수량)

		lib.F테스트_참임(t, math.Abs(float64(값.M매도손익금액)-매도손익금액) <= 1, 값.M매도손익금액, 매도손익금액)
		lib.F테스트_참임(t, 값.M손익율*float64(값.M평가손익) >= 0)
		lib.F테스트_참임(t, 값.M현재가 > 0)
		lib.F테스트_참임(t, 값.M신용금액 >= 0)
		lib.F테스트_참임(t, 값.M만기일.Equal(time.Time{}) || 값.M만기일.After(xing.F당일()))
		lib.F테스트_참임(t, 값.M전일매도체결가 >= 0)
		lib.F테스트_참임(t, 값.M전일매도수량 >= 0)
		lib.F테스트_참임(t, 값.M전일매수체결가 >= 0)
		lib.F테스트_참임(t, 값.M전일매수수량 >= 0)
		lib.F테스트_참임(t, 값.M대출일.Equal(time.Time{}) || 값.M대출일.Equal(xing.F당일()))
		lib.F테스트_참임(t, 값.M평균단가 >= 0)
		lib.F테스트_참임(t, 값.M매도가능수량 >= 0)
		lib.F테스트_참임(t, 값.M매도주문수량 >= 0)
		lib.F테스트_참임(t, 값.M금일매수체결금액 >= 0)
		lib.F테스트_참임(t, 값.M금일매도체결금액 >= 0)
		lib.F테스트_참임(t, 값.M전일매수체결금액 >= 0)
		lib.F테스트_참임(t, 값.M전일매도체결금액 >= 0)
		lib.F테스트_참임(t, 값.M잔고평가금액 > 0)

		// 평가손익 = 매입금액 - 평가금액 : 어렵다...
		//if ETF_ETN_종목_여부(값.M종목코드) { // 세율 0%, 모의서버 수수료 0.35%, 합계 0.35%
		//	//오차 := 값.M잔고평가금액 - int64(float64(값.M매입금액)*1.0035) - 값.M평가손익
		//	//lib.F테스트_참임(t, lib.F절대값_정수64(오차) <= 1, 오차, 값.M매입금액, 값.M잔고평가금액, 값.M평가손익, int64(float64(값.M매입금액)*1.0035))
		//} else { // 세율 0.25%, 모의서버 수수료 0.35%, 합계 0.6%
		//	오차 := 값.M잔고평가금액 - int64(float64(값.M매입금액)*1.006) - 값.M평가손익
		//	lib.F테스트_참임(t, lib.F절대값_정수64(오차) <= 1, 오차, 값.M평가손익, 값.M매입금액, int(float64(값.M매입금액)*1.006), 값.M잔고평가금액) // 평가손익 = 매입금액 - 평가금액
		//}

		lib.F테스트_참임(t, 값.M현금주문가능금액 >= 0)
		lib.F테스트_참임(t, 값.M주문가능금액 >= 0)
		lib.F테스트_참임(t, 값.M매도미체결수량 >= 0)
		lib.F테스트_참임(t, 값.M매도미결제수량 >= 0)
		lib.F테스트_참임(t, 값.M매수미체결수량 >= 0)
		lib.F테스트_참임(t, 값.M매수미결제수량 >= 0)
		lib.F테스트_참임(t, 값.M미결제수량 >= 0)
		lib.F테스트_참임(t, 값.M미체결수량 >= 0)
		lib.F테스트_참임(t, 값.M전일종가 > 0)
		lib.F테스트_참임(t, 값.M매입금액 > 0)
		lib.F테스트_같음(t, 값.M등록시장코드,
			xt.CSPAQ12300_코스피, xt.CSPAQ12300_코스닥, xt.CSPAQ12300_코넥스,
			xt.CSPAQ12300_K_OTC, xt.CSPAQ12300_채권, xt.CSPAQ12300_비상장)
		lib.F테스트_같음(t, 값.M대출상세분류코드,
			xt.CSPAQ12300_대출없음, xt.CSPAQ12300_유통융자,
			xt.CSPAQ12300_자기융자, xt.CSPAQ12300_예탁주식담보융자)
		lib.F테스트_참임(t, 값.M예탁담보대출수량 >= 0)
	}
}

func TestCSPAQ13700_현물계좌_주문체결내역(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()

	for i := 0; i < 30; i++ {
		일자 := xing.F당일().AddDate(0, 0, -1*i)
		testCSPAQ13700_현물계좌_주문체결내역_도우미(t, 계좌번호, 일자)
	}
}

func testCSPAQ13700_현물계좌_주문체결내역_도우미(t *testing.T, 계좌번호 string, 일자 time.Time) {
	값_모음, 에러 := xing.TrCSPAQ13700_현물계좌_주문체결내역(
		계좌번호, 일자, lib.P매도_매수_전체, xt.CSPAQ13700_체결)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, 값.M주문일.Before(xing.F당일().AddDate(0, 0, 1)))
		lib.F테스트_다름(t, 값.M관리지점번호, "")
		lib.F테스트_다름(t, 값.M주문시장코드, "")
		lib.F테스트_참임(t, 값.M주문번호 >= 0)
		lib.F테스트_참임(t, 값.M원주문번호 >= 0)
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드), 값.M종목코드)
		lib.F테스트_다름(t, 값.M종목명, "")
		lib.F테스트_같음(t, 값.M매도_매수_구분, lib.P매도, lib.P매수)
		lib.F테스트_같음(t, 값.M주문유형,
			xt.P주문유형_해당없음, xt.P주문_현금매도, xt.P주문_현금매수,
			xt.P주문_신용매도, xt.P주문_신용매수, xt.P주문_저축매도,
			xt.P주문_저축매수, xt.P주문_상품매도_대차, xt.P주문_상품매도,
			xt.P주문_상품매수, xt.P주문_현금매수_유가, xt.P주문_현금매수_정리, xt.P주문_장외매매) //xt.P주문_선물대용매도_일반, xt.P주문_선물대용매도_반대,
		lib.F테스트_같음(t, 값.M주문처리유형,
			xt.CSPAQ13700_정상처리, xt.CSPAQ13700_정정확인, xt.CSPAQ13700_정정거부_채권,
			xt.CSPAQ13700_취소확인, xt.CSPAQ13700_취소거부_채권)
		lib.F테스트_같음(t, 값.M정정취소구분, lib.P신규, lib.P정정, lib.P취소)
		lib.F테스트_참임(t, 값.M정정취소수량 >= 0)
		lib.F테스트_참임(t, 값.M정정취소가능수량 >= 0)
		lib.F테스트_참임(t, 값.M주문수량 >= 0)
		lib.F테스트_참임(t, 값.M주문가격 >= 0)
		lib.F테스트_참임(t, 값.M체결수량 >= 0)
		lib.F테스트_참임(t, 값.M체결가 >= 0)
		lib.F테스트_참임(t, 값.M체결처리시각.Hour() >= 9 && 값.M체결처리시각.Hour() <= 16, 값.M체결처리시각.Hour())
		lib.F테스트_참임(t, 값.M최종체결시각.Hour() >= 9 && 값.M최종체결시각.Hour() <= 16, 값.M최종체결시각.Hour())
		lib.F테스트_같음(t, 값.M호가유형,
			xt.P호가_지정가, xt.P호가_시장가, xt.P호가_조건부_지정가,
			xt.P호가_최유리_지정가, xt.P호가_최우선_지정가, xt.P호가_시장가_IOC,
			xt.P호가_최유리_지정가_IOC, xt.P호가_최유리_지정가_FOK, xt.P호가_지정가_전환,
			xt.P호가_지정가_IOC_전환, xt.P호가_지정가_FOK_전환, xt.P호가_부분충족_K_OTC,
			xt.P호가_전량충족_K_OTC, xt.P호가_장전_시간외, xt.P호가_장후_시간외,
			xt.P호가_시간외_단일가)
		lib.F테스트_같음(t, 값.M주문조건, lib.P주문조건_없음, lib.P주문조건_IOC, lib.P주문조건_FOK)
		lib.F테스트_참임(t, 값.M전체체결수량 >= 0)

		// 모의서버에서는 '50'이 수신되는 버그가 존재함. 게시판 질답에서 확인됨.
		lib.F테스트_같음(t, 값.M통신매체, xt.T통신매체구분(50),
			xt.P통신매체_아이폰, xt.P통신매체_안드로이드, xt.P통신매체_API, xt.P통신매체_HTS)
		lib.F테스트_다름(t, 값.M회원번호, "")
		lib.F테스트_같음(t, 값.M예약주문여부, xt.CSPAQ13700_예약주문_아님, xt.CSPAQ13700_예약주문)
		lib.F테스트_참임(t, 값.M대출일.Before(xing.F당일().AddDate(0, 0, 1)))
		lib.F테스트_참임(t, 값.M주문시각.Hour() >= 9 && 값.M주문시각.Hour() <= 16, 값.M주문시각.Hour())
		lib.F테스트_다름(t, 값.M운용지시번호, "")
		lib.F테스트_다름(t, 값.M주문자ID, "")
	}
}

func TestCSPAQ22200_현물계좌_예수금_주문가능금액(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()

	값, 에러 := xing.TrCSPAQ22200_현물계좌_예수금_주문가능금액(계좌번호)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_같음(t, 값.M계좌번호, 계좌번호)
	lib.F테스트_다름(t, 값.M지점명, "")
	lib.F테스트_다름(t, 값.M계좌명, "")
	lib.F테스트_참임(t, 값.M현금주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M대용주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M코스피금액 >= 0)
	lib.F테스트_참임(t, 값.M코스닥금액 >= 0)
	lib.F테스트_참임(t, 값.M신용담보주문금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금률100퍼센트주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금률35퍼센트주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금률50퍼센트주문가능금액 >= 0)
	lib.F테스트_참임(t, 값.M신용주문가능금액 >= 0)
	//lib.F테스트_참임(t, 값.M예수금 >= 0, 값.M예수금)
	lib.F테스트_참임(t, 값.M대용금액 >= 0)
	lib.F테스트_참임(t, 값.M증거금_현금 >= 0)
	lib.F테스트_참임(t, 값.M증거금_대용 >= 0)
	lib.F테스트_참임(t, 값.D1_예수금 >= 0)
	lib.F테스트_참임(t, 값.D2_예수금 >= 0)
	lib.F테스트_참임(t, 값.M미수금액 >= 0)
	lib.F테스트_참임(t, 값.D1연체변제소요금액 >= 0)
	lib.F테스트_참임(t, 값.D2연체변제소요금액 >= 0)
	lib.F테스트_같음(t, 값.M융자금액, 0)
	lib.F테스트_같음(t, 값.M변경후담보비율, 0.0)
	lib.F테스트_같음(t, 값.M소요담보금액, 0)
	lib.F테스트_같음(t, 값.M담보부족금액, 0)
	lib.F테스트_같음(t, 값.M원담보합계금액, 0)
	lib.F테스트_같음(t, 값.M부담보합계금액, 0)
	lib.F테스트_같음(t, 값.M신용담보금현금, 0)
	lib.F테스트_같음(t, 값.M신용담보대용금액, 0)
	lib.F테스트_같음(t, 값.M신용설정보증금, 0)
	lib.F테스트_같음(t, 값.M신용담보재사용금액, 0)
	lib.F테스트_같음(t, 값.M처분제한금액, 0)
	lib.F테스트_참임(t, 값.M전일매도정산금액 >= 0)
	lib.F테스트_참임(t, 값.M전일매수정산금액 >= 0)
	lib.F테스트_참임(t, 값.M금일매도정산금액 >= 0)
	lib.F테스트_참임(t, 값.M금일매수정산금액 >= 0)
	lib.F테스트_같음(t, 값.M매도대금담보대출금액, 0)
}

func TestCSPAT00600_현물_정상_주문(t *testing.T) {
	t.Parallel()

	if xt.F서버_구분() == xt.P서버_실거래 ||
		!xing.F금일_한국증시_개장() ||
		!krx.F한국증시_정규_거래_시간임() {
		t.SkipNow()
	}

	소켓SUB_실시간 := nano.NewNano소켓SUB_단순형(xt.F주소_실시간())
	lib.F대기(lib.P1초)

	lib.F테스트_에러없음(t, xing.F주문_응답_실시간_정보_구독())

	const 반복_횟수 = 10
	const 수량 = 5 // 주문이 정상 작동하는 지만 확인하면 됨.
	const 호가_유형 = lib.P호가_시장가

	var 매수_주문_접수_확인_수량, 매도_주문_접수_확인_수량 int
	var 매수_체결_수량, 매도_체결_수량 int64
	var 매수_주문번호_모음, 매도_주문번호_모음 = make([]int64, 반복_횟수), make([]int64, 반복_횟수)
	var 종목 = lib.New종목("069500", "KODEX 200", lib.P시장구분_ETF)
	var 가격_정상주문 = int64(0)
	var p1분전 = time.Now().Add(-1 * lib.P1분)
	var p1분후 = time.Now().Add(lib.P1분)

	계좌번호 := f테스트용_현물_계좌번호()

	질의값_매수 := xt.NewCSPAT00600_현물_정상_주문_질의값()
	질의값_매수.M계좌번호 = 계좌번호
	질의값_매수.M종목코드 = 종목.G코드()
	질의값_매수.M주문수량 = 수량
	질의값_매수.M주문단가 = 가격_정상주문 // 시장가 주문 시 가격은 무조건 '0'을 입력해야 함.
	질의값_매수.M매도_매수_구분 = lib.P매수
	질의값_매수.M호가유형 = 호가_유형
	질의값_매수.M신용거래_구분 = lib.P신용거래_해당없음
	질의값_매수.M주문조건 = lib.P주문조건_없음 // 모의투자에서는 IOC, FOK를 사용할 수 없음.
	질의값_매수.M대출일 = ""

	for i := 0; i < 반복_횟수; i++ {
		응답값, 에러 := xing.TrCSPAT00600_현물_정상주문(질의값_매수)

		lib.F대기(lib.P100밀리초)

		lib.F테스트_에러없음(t, 에러)
		lib.F테스트_다름(t, 응답값.M응답1, nil)
		lib.F테스트_같음(t, 응답값.M응답1.M주문수량, 수량)
		lib.F테스트_같음(t, 응답값.M응답1.M종목코드, 종목.G코드())
		lib.F테스트_같음(t, 응답값.M응답1.M호가유형, xt.F2Xing호가유형(호가_유형, lib.P주문조건_없음))
		lib.F테스트_같음(t, 응답값.M응답1.M주문가격, 가격_정상주문)
		lib.F테스트_같음(t, 응답값.M응답1.M신용거래_구분, lib.P신용거래_해당없음)
		lib.F테스트_같음(t, 응답값.M응답1.M주문조건_구분, lib.P주문조건_없음)
		lib.F테스트_다름(t, 응답값.M응답2, nil)
		lib.F테스트_같음(t, 응답값.M응답2.M종목코드, 종목.G코드())
		lib.F테스트_참임(t, 응답값.M응답2.M주문번호 > 0)
		lib.F테스트_참임(t, 응답값.M응답2.M주문시각.After(p1분전), 응답값.M응답2.M주문시각, p1분전)
		lib.F테스트_참임(t, 응답값.M응답2.M주문시각.Before(p1분후), 응답값.M응답2.M주문시각, p1분후)

		매수_주문번호_모음[i] = 응답값.M응답2.M주문번호
	}

	// 매수 주문 확인
	for {
		바이트_변환_모음, 에러 := 소켓SUB_실시간.G수신()
		lib.F테스트_에러없음(t, 에러)

		실시간_정보, ok := 바이트_변환_모음.S해석기(xt.F바이트_변환값_해석).G해석값_단순형(0).(*xt.S현물_주문_응답_실시간_정보)

		switch {
		case !ok:
			continue
		case !f주문번호_포함(실시간_정보.M주문번호, 매수_주문번호_모음):
			continue
		}

		switch 실시간_정보.RT코드 {
		case xt.RT현물_주문_거부_SC4:
			lib.F문자열_출력("매수 주문 거부됨 : '%v'", 실시간_정보.M주문번호)
			t.FailNow()
		case xt.RT현물_주문_정정_SC2, xt.RT현물_주문_취소_SC3:
			lib.F문자열_출력("예상하지 못한 TR코드 : '%v'", 실시간_정보.RT코드)
			t.FailNow()
		case xt.RT현물_주문_접수_SC0:
			매수_주문_접수_확인_수량++
		case xt.RT현물_주문_체결_SC1:
			매수_체결_수량 = 매수_체결_수량 + 실시간_정보.M수량
		}

		if 매수_주문_접수_확인_수량 == 반복_횟수 &&
			매수_체결_수량 == 반복_횟수*수량 {
			break
		}
	}

	질의값_매도 := xt.NewCSPAT00600_현물_정상_주문_질의값()
	질의값_매도.M계좌번호 = 계좌번호
	질의값_매도.M종목코드 = 종목.G코드()
	질의값_매도.M주문수량 = 수량
	질의값_매도.M주문단가 = 가격_정상주문
	질의값_매도.M매도_매수_구분 = lib.P매도
	질의값_매도.M호가유형 = 호가_유형
	질의값_매도.M신용거래_구분 = lib.P신용거래_해당없음
	질의값_매도.M주문조건 = lib.P주문조건_없음
	질의값_매도.M대출일 = ""

	for i := 0; i < 반복_횟수; i++ {
		응답값, 에러 := xing.TrCSPAT00600_현물_정상주문(질의값_매도)

		lib.F대기(lib.P100밀리초)

		lib.F테스트_에러없음(t, 에러)
		lib.F테스트_다름(t, 응답값.M응답1, nil)
		lib.F테스트_같음(t, 응답값.M응답1.M주문수량, 수량)
		lib.F테스트_같음(t, 응답값.M응답1.M종목코드, 종목.G코드())
		lib.F테스트_같음(t, 응답값.M응답1.M호가유형, xt.F2Xing호가유형(호가_유형, lib.P주문조건_없음))
		lib.F테스트_같음(t, 응답값.M응답1.M주문가격, 가격_정상주문)
		lib.F테스트_같음(t, 응답값.M응답1.M신용거래_구분, lib.P신용거래_해당없음)
		lib.F테스트_같음(t, 응답값.M응답1.M주문조건_구분, lib.P주문조건_없음)
		lib.F테스트_다름(t, 응답값.M응답2, nil)
		lib.F테스트_같음(t, 응답값.M응답2.M종목코드, 종목.G코드())
		lib.F테스트_참임(t, 응답값.M응답2.M주문번호 > 0)
		lib.F테스트_참임(t, 응답값.M응답2.M주문시각.After(p1분전), 응답값.M응답2.M주문시각, p1분전)
		lib.F테스트_참임(t, 응답값.M응답2.M주문시각.Before(p1분후), 응답값.M응답2.M주문시각, p1분후)

		매도_주문번호_모음[i] = 응답값.M응답2.M주문번호
	}

	// 매도 주문 확인
	for {
		바이트_변환_모음, 에러 := 소켓SUB_실시간.G수신()
		lib.F테스트_에러없음(t, 에러)

		실시간_정보, ok := 바이트_변환_모음.S해석기(xt.F바이트_변환값_해석).G해석값_단순형(0).(*xt.S현물_주문_응답_실시간_정보)

		switch {
		case !ok:
			continue
		case !f주문번호_포함(실시간_정보.M주문번호, 매도_주문번호_모음):
			continue
		}

		switch 실시간_정보.RT코드 {
		case xt.RT현물_주문_거부_SC4:
			lib.F문자열_출력("매도 주문 거부됨 : '%v'", 실시간_정보.M주문번호)
			t.FailNow()
		case xt.RT현물_주문_정정_SC2, xt.RT현물_주문_취소_SC3:
			lib.F문자열_출력("예상하지 못한 TR코드 : '%v'", 실시간_정보.RT코드)
			t.FailNow()
		case xt.RT현물_주문_접수_SC0:
			매도_주문_접수_확인_수량++
		case xt.RT현물_주문_체결_SC1:
			매도_체결_수량 = 매도_체결_수량 + 실시간_정보.M수량
		}

		if 매도_주문_접수_확인_수량 == 반복_횟수 &&
			매도_체결_수량 == 반복_횟수*수량 {
			break
		}
	}
}

func f주문번호_포함(주문번호 int64, 주문번호_모음 []int64) bool {
	for _, 주문번호2 := range 주문번호_모음 {
		if 주문번호 == 주문번호2 {
			return true
		}
	}

	return false
}

func TestCSPAT00700_현물_정정_주문(t *testing.T) {
	t.Parallel()

	if xt.F서버_구분() == xt.P서버_실거래 ||
		!xing.F금일_한국증시_개장() ||
		!krx.F한국증시_정규_거래_시간임() {
		t.SkipNow()
	}

	소켓SUB_실시간 := nano.NewNano소켓SUB_단순형(xt.F주소_실시간())
	lib.F대기(lib.P1초)

	lib.F테스트_에러없음(t, xing.F주문_응답_실시간_정보_구독())

	const 반복_횟수 = 10
	const 수량 = int64(5)
	const 수량_전량_취소주문 = int64(0)

	종목 := lib.New종목("069500", "KODEX 200", lib.P시장구분_ETF)

	하한가, 에러 := xing.F하한가(종목.G코드())
	lib.F테스트_참임(t, 에러 == nil && 하한가 > 0, "하한가를 찾을 수 없음. %v", 종목.G코드())

	가격_정상주문 := 하한가
	최소_호가단위, 에러 := xing.F최소_호가단위by종목(종목)
	lib.F테스트_에러없음(t, 에러)

	계좌번호 := f테스트용_현물_계좌번호()

	계좌_상세명, 에러 := xing.F계좌_상세명(계좌번호)
	lib.F확인(에러)
	lib.F테스트_거짓임(t, strings.Contains(계좌_상세명, "선물옵션")) // 현물 계좌이어야 함.

	질의값 := xt.NewCSPAT00600_현물_정상_주문_질의값()
	질의값.M계좌번호 = 계좌번호
	질의값.M종목코드 = 종목.G코드()
	질의값.M주문수량 = 수량
	질의값.M주문단가 = 가격_정상주문 // 시장가 주문 시 가격은 무조건 '0'을 입력해야 함.
	질의값.M매도_매수_구분 = lib.P매수
	질의값.M호가유형 = lib.P호가_지정가
	질의값.M신용거래_구분 = lib.P신용거래_해당없음
	질의값.M주문조건 = lib.P주문조건_없음 // 모의투자에서는 IOC, FOK를 사용할 수 없음.
	질의값.M대출일 = ""            // 신용주문이 아닐 경우는 NewCSPAT00600InBlock1()에서 공백문자로 바꿔줌.

	정상주문_응답값, 에러 := xing.TrCSPAT00600_현물_정상주문(질의값)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 정상주문_응답값.M응답2.M주문번호 > 0, 정상주문_응답값.M응답2.M주문번호)

	lib.F대기(lib.P100밀리초)

	원주문번호 := 정상주문_응답값.M응답2.M주문번호

	질의값_정정주문 := xt.NewCSPAT00700_현물_정정_주문_질의값()
	질의값_정정주문.M구분 = xt.TR주문
	질의값_정정주문.M코드 = xt.TR현물_정정_주문_CSPAT00700
	질의값_정정주문.M원주문번호 = 원주문번호
	질의값_정정주문.M계좌번호 = 계좌번호
	질의값_정정주문.M종목코드 = 종목.G코드()
	질의값_정정주문.M주문수량 = 수량
	질의값_정정주문.M호가유형 = lib.P호가_지정가
	질의값_정정주문.M주문조건 = lib.P주문조건_없음
	질의값_정정주문.M주문단가 = 가격_정상주문

	// 정정 주문 TR 실행
	for i := 0; i < 반복_횟수; i++ {
		//lib.F체크포인트("** 00700테스트 **", i, 질의값_정정주문.M원주문번호)

		switch 질의값_정정주문.M주문단가 {
		case 가격_정상주문, 가격_정상주문 + int64(최소_호가단위):
			질의값_정정주문.M주문단가 += int64(최소_호가단위)
		case 가격_정상주문 + (2 * int64(최소_호가단위)):
			질의값_정정주문.M주문단가 -= int64(최소_호가단위)
		default:
			panic(lib.New에러("예상하지 못한 값 : '%v'", 질의값_정정주문.M주문단가))
		}

		정정주문_응답값, 에러 := xing.TrCSPAT00700_현물_정정주문(질의값_정정주문)
		lib.F테스트_에러없음(t, 에러)
		lib.F테스트_참임(t, 정정주문_응답값.M응답2.M주문번호 > 0, 정정주문_응답값.M응답2.M주문번호)
		lib.F테스트_같음(t, 정정주문_응답값.M응답2.M모_주문번호, 정상주문_응답값.M응답2.M주문번호)
		lib.F테스트_같음(t, 정정주문_응답값.M응답1.M원_주문번호, 원주문번호)

		원주문번호 = 정정주문_응답값.M응답2.M주문번호
		질의값_정정주문.M원주문번호 = 원주문번호

		lib.F대기(lib.P100밀리초)
	}

	// 전량 취소
	질의값_취소주문 := lib.New질의값_취소_주문()
	질의값_취소주문.M구분 = xt.TR주문
	질의값_취소주문.M코드 = xt.TR현물_취소_주문_CSPAT00800
	질의값_취소주문.M원주문번호 = 원주문번호
	질의값_취소주문.M계좌번호 = 계좌번호
	질의값_취소주문.M종목코드 = 종목.G코드()
	질의값_취소주문.M주문수량 = 수량_전량_취소주문

	취소주문_응답값, 에러 := xing.TrCSPAT00800_현물_취소주문(질의값_취소주문)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 취소주문_응답값.M응답2.M주문번호 > 0, 취소주문_응답값.M응답2.M주문번호)

	lib.F대기(lib.P100밀리초)

	// 취소 주문 확인
	취소_주문_접수, 취소_주문_처리 := false, false

	for {
		바이트_변환_모음, 에러 := 소켓SUB_실시간.G수신()
		lib.F테스트_에러없음(t, 에러)

		실시간_정보, ok := 바이트_변환_모음.S해석기(xt.F바이트_변환값_해석).G해석값_단순형(0).(*xt.S현물_주문_응답_실시간_정보)

		switch {
		case !ok:
			continue
		case 실시간_정보.M원_주문번호 != 원주문번호:
			continue
		}

		switch 실시간_정보.RT코드 {
		case xt.RT현물_주문_거부_SC4:
			lib.F문자열_출력("취소 주문 거부됨 : '%v'", 정상주문_응답값.M응답2.M주문번호)
			t.FailNow()
		case xt.RT현물_주문_체결_SC1, xt.RT현물_주문_정정_SC2:
			lib.F문자열_출력("예상하지 못한 TR코드 : '%v'", 실시간_정보.RT코드)
			t.FailNow()
		case xt.RT현물_주문_접수_SC0:
			취소_주문_접수 = true
		case xt.RT현물_주문_취소_SC3:
			취소_주문_처리 = true
		}

		if 취소_주문_접수 && 취소_주문_처리 {
			break
		}
	}
}

func TestCSPAT00800_현물_취소_주문(t *testing.T) {
	t.Parallel()

	if xt.F서버_구분() == xt.P서버_실거래 ||
		!xing.F금일_한국증시_개장() ||
		!krx.F한국증시_정규_거래_시간임() {
		t.SkipNow()
	}

	lib.F테스트_에러없음(t, xing.F주문_응답_실시간_정보_구독())

	var 종목 = lib.New종목("069500", "KODEX 200", lib.P시장구분_ETF)

	하한가, 에러 := xing.F하한가(종목.G코드())
	lib.F테스트_참임(t, 에러 == nil && 하한가 > 0, "하한가를 찾을 수 없음. %v", 종목.G코드())

	const 수량_정상주문 = int64(25)
	const 수량_일부_취소_주문 = int64(10)
	const 수량_전량_취소_주문 = 수량_정상주문 - 수량_일부_취소_주문
	var 가격_정상주문 = 하한가

	계좌번호 := f테스트용_현물_계좌번호()

	계좌_상세명, 에러 := xing.F계좌_상세명(계좌번호)
	lib.F확인(에러)
	lib.F테스트_거짓임(t, strings.Contains(계좌_상세명, "선물옵션")) // 현물 계좌이어야 함.

	질의값 := xt.NewCSPAT00600_현물_정상_주문_질의값()
	질의값.M계좌번호 = 계좌번호
	질의값.M종목코드 = 종목.G코드()
	질의값.M주문수량 = 수량_정상주문
	질의값.M주문단가 = 가격_정상주문 // 시장가 주문 시 가격은 무조건 '0'을 입력해야 함.
	질의값.M매도_매수_구분 = lib.P매수
	질의값.M호가유형 = lib.P호가_지정가
	질의값.M신용거래_구분 = lib.P신용거래_해당없음
	질의값.M주문조건 = lib.P주문조건_없음 // 모의투자에서는 IOC, FOK를 사용할 수 없음.
	질의값.M대출일 = ""            // 신용주문이 아닐 경우는 NewCSPAT00600InBlock1()에서 공백문자로 바꿔줌.

	정상주문_응답값, 에러 := xing.TrCSPAT00600_현물_정상주문(질의값)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 정상주문_응답값.M응답2.M주문번호 > 0, 정상주문_응답값.M응답2.M주문번호)

	lib.F대기(lib.P100밀리초)

	질의값_취소주문 := lib.New질의값_취소_주문()
	질의값_취소주문.M구분 = xt.TR주문
	질의값_취소주문.M코드 = xt.TR현물_취소_주문_CSPAT00800
	질의값_취소주문.M원주문번호 = 정상주문_응답값.M응답2.M주문번호
	질의값_취소주문.M계좌번호 = 계좌번호
	질의값_취소주문.M종목코드 = 종목.G코드()
	질의값_취소주문.M주문수량 = 수량_일부_취소_주문

	취소주문_응답값, 에러 := xing.TrCSPAT00800_현물_취소주문(질의값_취소주문)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 취소주문_응답값.M응답2.M주문번호 > 0, 취소주문_응답값.M응답2.M주문번호)

	lib.F대기(lib.P100밀리초)

	// 전량 취소주문 TR 실행
	질의값_취소주문 = lib.New질의값_취소_주문()
	질의값_취소주문.M구분 = xt.TR주문
	질의값_취소주문.M코드 = xt.TR현물_취소_주문_CSPAT00800
	질의값_취소주문.M원주문번호 = 정상주문_응답값.M응답2.M주문번호
	질의값_취소주문.M계좌번호 = 계좌번호
	질의값_취소주문.M종목코드 = 종목.G코드()
	질의값_취소주문.M주문수량 = 수량_전량_취소_주문

	취소주문_응답값, 에러 = xing.TrCSPAT00800_현물_취소주문(질의값_취소주문)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, 취소주문_응답값.M응답2.M주문번호 > 0, 취소주문_응답값.M응답2.M주문번호)
}

func TestT0150_현물_당일_매매일지(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()

	응답값_모음, 에러 := xing.TrT0150_현물_당일_매매일지(계좌번호)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 응답값_모음 {
		lib.F테스트_같음(t, 값.M매도_매수_구분, lib.P매도, lib.P매수)
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드), 값.M종목코드)
		lib.F테스트_참임(t, 값.M수량 > 0)
		lib.F테스트_참임(t, 값.M단가 > 0)
		lib.F테스트_참임(t, 값.M약정금액 > 0)

		// 매도 매수 상관없이 수수료는 종목 소계에서 구해집니다.
		// 종목 소계의 수수료 항목 확인 부탁드립니다.

		switch 값.M매도_매수_구분 {
		case lib.P매수:
			lib.F테스트_같음(t, 값.M농특세, 0)
		case lib.P매도:
			if xing.ETF_ETN_종목_여부(값.M종목코드) {
				lib.F테스트_같음(t, 값.M거래세, 0)
				lib.F테스트_같음(t, 값.M농특세, 0)
			} else {
				예상_금액 := 0.003 * float64(값.M수량) * float64(값.M단가)
				lib.F테스트_참임(t, 값.M거래세 > 0 && float64(값.M거래세) < 예상_금액*1.1,
					값.M종목코드, 값.M거래세, 예상_금액)
				lib.F테스트_참임(t, 값.M농특세 > 0 && float64(값.M농특세) < 예상_금액*1.1,
					값.M종목코드, 값.M거래세, 예상_금액)
			}
		}

		예상_정산금액 := (값.M단가 * 값.M수량) - 값.M거래세 - 값.M농특세 //  - 값.M수수료
		lib.F테스트_같음(t, 값.M정산금액, 예상_정산금액)
	}
}

func TestT0151_일자별_매매일지(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()

	값_모음, 에러 := xing.TrT0151_현물_일자별_매매일지(계좌번호, xing.F전일())
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_같음(t, 값.M매도_매수_구분, lib.P매도, lib.P매수)
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드), 값.M종목코드)
		lib.F테스트_참임(t, 값.M수량 > 0)
		lib.F테스트_참임(t, 값.M단가 > 0)
		lib.F테스트_참임(t, 값.M약정금액 > 0)

		switch 값.M매도_매수_구분 {
		case lib.P매수:
			lib.F테스트_같음(t, 값.M농특세, 0)
		case lib.P매도:
			if xing.ETF_ETN_종목_여부(값.M종목코드) {
				lib.F테스트_같음(t, 값.M거래세, 0)
				lib.F테스트_같음(t, 값.M농특세, 0)
			} else {
				예상_금액 := 0.003 * float64(값.M수량) * float64(값.M단가)
				lib.F테스트_참임(t, 값.M거래세 > 0 && float64(값.M거래세) < 예상_금액*1.1,
					값.M종목코드, 값.M거래세, 예상_금액)
				lib.F테스트_참임(t, 값.M농특세 > 0 && float64(값.M농특세) < 예상_금액*1.1,
					값.M종목코드, 값.M거래세, 예상_금액)
			}
		}

		예상_정산금액 := (값.M단가 * 값.M수량) - 값.M거래세 - 값.M농특세 //  - 값.M수수료
		lib.F테스트_같음(t, 값.M정산금액, 예상_정산금액)
	}
}

func TestT0167_시각_조회(t *testing.T) {
	t.Parallel()

	시각, 에러 := xing.TrT0167_시각_조회()

	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_같음(t, 시각.Year(), time.Now().Year())
	lib.F테스트_같음(t, 시각.Month(), time.Now().Month())
	lib.F테스트_같음(t, 시각.Day(), time.Now().Day())

	지금 := time.Now()
	차이 := 시각.Sub(지금)
	lib.F테스트_참임(t, 차이 > (-1*lib.P1시간) && 차이 < lib.P1시간, 시각, 지금)
}

func TestT0425_현물_체결_미체결_확인(t *testing.T) {
	t.Parallel()

	계좌번호 := f테스트용_현물_계좌번호()
	종목코드 := "069500"

	체결_구분_모음 := []lib.T체결_구분{lib.P체결구분_전체, lib.P체결구분_체결, lib.P체결구분_미체결}
	체결_구분 := 체결_구분_모음[lib.F임의_범위_이내_정수값(0, len(체결_구분_모음)-1)]

	매도_매수_구분_모음 := []lib.T매도_매수_구분{lib.P매도_매수_전체, lib.P매도, lib.P매수}
	매도_매수_구분 := 매도_매수_구분_모음[lib.F임의_범위_이내_정수값(0, len(매도_매수_구분_모음)-1)]

	값_모음, 에러 := xing.TrT0425_현물_체결_미체결_조회(계좌번호, 종목코드, 체결_구분, 매도_매수_구분)
	lib.F테스트_에러없음(t, 에러)

	if xing.F당일().Equal(lib.F2일자(time.Now())) &&
		time.Now().Hour() >= 9 &&
		time.Now().Hour() < 4 {
		lib.F테스트_다름(t, len(값_모음), 0)
	}

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, 값.M주문_번호 > 0)
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드), 값.M종목코드)
		lib.F테스트_다름(t, 값.M매매_구분, "")
		lib.F테스트_참임(t, 값.M주문_수량 > 0)

		switch {
		case 값.M매매_구분 == "매도취소",
			값.M매매_구분 == "매수취소",
			값.M유형 == "시장가":
			lib.F테스트_같음(t, 값.M주문_가격, 0)
		default:
			lib.F테스트_참임(t, 값.M주문_가격 > 0, 값.M주문_가격)
		}

		lib.F테스트_참임(t, 값.M체결_수량 >= 0)
		lib.F테스트_참임(t, 값.M체결_가격 >= 0)
		lib.F테스트_참임(t, 값.M미체결_잔량 >= 0)
		lib.F테스트_참임(t, 값.M확인_수량 >= 0)
		lib.F테스트_다름(t, 값.M상태, "")
		lib.F테스트_참임(t, 값.M원_주문_번호 >= 0)

		if 값.M상태 == "취소확인" {
			lib.F테스트_같음(t, 값.M유형, "")
		} else {
			lib.F테스트_다름(t, 값.M유형, "")
		}

		lib.F테스트_참임(t, 값.M주문_시간.After(lib.F금일().AddDate(-10, 0, 0)))
		lib.F테스트_다름(t, 값.M주문_매체, "")
		lib.F테스트_참임(t, 값.M처리_순번 >= 0)
		lib.F테스트_같음(t, 값.M호가_유형, xt.P호가_지정가, xt.P호가_시장가, xt.P호가_조건부_지정가,
			xt.P호가_최유리_지정가, xt.P호가_최우선_지정가, xt.P호가_지정가_IOC, xt.P호가_시장가_IOC,
			xt.P호가_최유리_지정가_IOC, xt.P호가_지정가_FOK, xt.P호가_시장가_FOK, xt.P호가_최유리_지정가_FOK,
			xt.P호가_장전_시간외, xt.P호가_장후_시간외, xt.P호가_시간외_단일가)
		lib.F테스트_참임(t, 값.M현재가 > 0)

		lib.F테스트_같음(t, 값.M주문_구분, xt.P주문유형_해당없음, xt.P주문_현금매도, xt.P주문_현금매수,
			xt.P주문_신용매도, xt.P주문_신용매수, xt.P주문_저축매도, xt.P주문_저축매수,
			xt.P주문_상품매도_대차, xt.P주문_상품매도, xt.P주문_상품매수, //xt.P주문_선물대용매도_일반, xt.P주문_선물대용매도_반대,
			xt.P주문_현금매도_프, xt.P주문_현금매수_프,
			xt.P주문_현금매수_유가, xt.P주문_현금매수_정리, xt.P주문_상품매도_대차_프,
			xt.P주문_상품매도_프, xt.P주문_상품매수_프)

		lib.F테스트_같음(t, 값.M신용_구분, xt.P현금, xt.P자기_융자, xt.P자기_융자_상환, xt.P유통_대주, xt.P유통_대주_상환, xt.P담보_대출)
		lib.F테스트_참임(t, 값.M대출_일자.Equal(time.Time{}) || 값.M대출_일자.After(lib.F금일().AddDate(-10, 0, 0)))
	}
}

func TestT1101_현물_호가_조회(t *testing.T) {
	t.Parallel()

	const 종목코드 = "069500" // 코덱스200

	값, 에러 := xing.TrT1101_현물_호가_조회(종목코드)
	lib.F테스트_에러없음(t, 에러)

	lib.F테스트_다름(t, 값.M종목명, "")
	lib.F테스트_참임(t, 값.M현재가 >= 0)
	lib.F테스트_같음(t, 값.M전일대비구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
	lib.F테스트_참임(t, 값.M전일대비등락폭 >= 0)

	switch 값.M전일대비구분 { // 등락율 확인
	case xt.P구분_상한, xt.P구분_상승:
		lib.F테스트_참임(t, 값.M등락율 >= 0)
	case xt.P구분_하한, xt.P구분_하락:
		lib.F테스트_참임(t, 값.M등락율 <= 0)
	case xt.P구분_보합:
		lib.F테스트_같음(t, 값.M등락율, 0)
	}

	lib.F테스트_참임(t, 값.M거래량 >= 0)
	lib.F테스트_참임(t, 값.M전일종가 >= 0)
	lib.F테스트_같음(t, len(값.M매도_호가_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_호가_모음), 10)
	lib.F테스트_같음(t, len(값.M매도_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.M매도_직전대비수량_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_직전대비수량_모음), 10)

	var 매도호가수량합, 매수호가수량합 int64
	// 게시판 문의 답변 내용 : (직전매도, 직전매수) 대비수량합과 1~10의 합계는 일치하지 않습니다.

	for i := 0; i < 10; i++ {
		lib.F테스트_참임(t, 값.M매도_호가_모음[i] >= 0, 값.M매도_호가_모음[i])
		lib.F테스트_참임(t, 값.M매수_호가_모음[i] >= 0, 값.M매수_호가_모음[i])
		lib.F테스트_참임(t, 값.M매도_잔량_모음[i] >= 0, 값.M매도_잔량_모음[i])
		lib.F테스트_참임(t, 값.M매수_잔량_모음[i] >= 0, 값.M매수_잔량_모음[i])

		// (-) 값이 나오더라..
		//lib.F테스트_참임(t, 값.M매도_직전대비수량_모음[i] >= 0, 값.M매도_직전대비수량_모음[i])
		//lib.F테스트_참임(t, 값.M매수_직전대비수량_모음[i] >= 0, 값.M매수_직전대비수량_모음[i])

		매도호가수량합 = 매도호가수량합 + 값.M매도_잔량_모음[i]
		매수호가수량합 = 매수호가수량합 + 값.M매수_잔량_모음[i]
	}

	if xing.F금일_한국증시_개장() && krx.F한국증시_정규_거래_시간임() {
		lib.F테스트_참임(t, 값.M시각.After(time.Now().Add(-1*lib.P10분)),
			값.M시각.Format("15:04:06"), time.Now().Add(-1*lib.P10분).Format("15:04:06"))
		lib.F테스트_참임(t, 값.M시각.Before(time.Now().Add(lib.P10분)),
			time.Now().Add(lib.P10분).Format("15:04:06"), 값.M시각.Format("15:04:06"))
	}

	if 값.M예상체결가격 != 0 {
		lib.F테스트_참임(t, float64(값.M예상체결가격) >= float64(값.M현재가)*0.7)
		lib.F테스트_참임(t, float64(값.M예상체결가격) <= float64(값.M현재가)*1.3)
		lib.F테스트_참임(t, 값.M예상체결수량 >= 0)
	}

	lib.F테스트_같음(t, 값.M예상체결전일구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
	lib.F테스트_참임(t, 값.M예상체결전일대비 >= 0)

	switch 값.M예상체결전일구분 { // 예상 체결 등락율 확인
	case xt.P구분_상한, xt.P구분_상승:
		lib.F테스트_참임(t, 값.M예상체결등락율 >= 0)
	case xt.P구분_하한, xt.P구분_하락:
		lib.F테스트_참임(t, 값.M예상체결등락율 <= 0)
	case xt.P구분_보합:
		lib.F테스트_같음(t, 값.M예상체결등락율, 0)
	}

	lib.F테스트_참임(t, 값.M시간외매도잔량 >= 0)
	lib.F테스트_참임(t, 값.M시간외매수잔량 >= 0)
	lib.F테스트_같음(t, 값.M동시호가_구분, xt.P동시호가_아님, xt.P동시호가_장중, xt.P동시호가_시간외, xt.P동시호가_동시)
	lib.F테스트_같음(t, len(값.M종목코드), 6)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M현재가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M하한가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M고가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M저가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M현재가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M시가 || 값.M시가 == 0)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M고가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M저가 || 값.M저가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M현재가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M시가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M저가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M저가 <= 값.M현재가)
}

func TestT1102_현물_시세_조회(t *testing.T) {
	t.Parallel()

	if lib.F지금().Hour() >= 5 && lib.F지금().Hour() < 9 {
		t.SkipNow() // 이 시간대에 테스트 에러가 발생함.
	}

	const 종목코드 = "069500" // KODEX 200
	당일 := xing.F당일()
	개장_시간 := time.Date(당일.Year(), 당일.Month(), 당일.Day(), 8, 0, 0, 0, 당일.Location())

	값, 에러 := xing.TrT1102_현물_시세_조회(종목코드)
	lib.F테스트_에러없음(t, 에러)

	switch 값.M전일대비구분 { // 등락율 확인
	case xt.P구분_상한, xt.P구분_상승:
		lib.F테스트_참임(t, 값.M등락율 >= 0)
	case xt.P구분_하한, xt.P구분_하락:
		lib.F테스트_참임(t, 값.M등락율 <= 0)
	case xt.P구분_보합:
		lib.F테스트_같음(t, 값.M등락율, 0)
	}

	lib.F테스트_참임(t, 값.M거래량 >= 0)
	lib.F테스트_참임(t, 값.M가중평균 > 값.M하한가 || 값.M가중평균 == 0, 값.M가중평균, 값.M하한가) // 가중평균 = 누적거래대금 / 누적거래량
	lib.F테스트_참임(t, 값.M가중평균 < 값.M상한가 || 값.M가중평균 == 0, 값.M가중평균, 값.M상한가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M현재가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M하한가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M고가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M저가)
	lib.F테스트_참임(t, 값.M52주_최고가 >= 값.M기준가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M현재가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M하한가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M고가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M저가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M기준가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M52주_최저가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M현재가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M시가, 값.M종목코드, 값.M하한가, 값.M시가, 값.M종목코드)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M고가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M저가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M기준가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M현재가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M저가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M52주_최저가)
	lib.F테스트_참임(t, 값.M저가 <= 값.M현재가)
	lib.F테스트_참임(t, 값.M저가 >= 값.M52주_최저가)
	lib.F테스트_참임(t, 값.M52주_최저가 > 0)
	lib.F테스트_참임(t, 값.M전일거래량 >= 0)
	lib.F테스트_같음(t, 값.M거래량차, lib.F절대값_실수(값.M전일거래량-값.M거래량))
	lib.F테스트_참임(t, 값.M시가시간.After(개장_시간.Add(-1*lib.P10분)), 값.M시가시간, 개장_시간.Add(-1*lib.P10분))
	lib.F테스트_참임(t, 값.M시가시간.Before(당일.Add(lib.P1일)), 값.M시가시간, 당일.Add(lib.P1일))
	lib.F테스트_참임(t, 값.M고가시간.After(개장_시간.Add(-1*lib.P10분)))
	lib.F테스트_참임(t, 값.M고가시간.Before(당일.Add(lib.P1일)))
	lib.F테스트_참임(t, 값.M고가시간.After(값.M시가시간) || 값.M고가시간.Equal(값.M시가시간))
	lib.F테스트_참임(t, 값.M저가시간.After(개장_시간.Add(-1*lib.P10분)))
	lib.F테스트_참임(t, 값.M저가시간.Before(당일.Add(lib.P1일)))
	lib.F테스트_참임(t, 값.M저가시간.After(값.M시가시간) || 값.M저가시간.Equal(값.M시가시간))
	lib.F테스트_참임(t, 값.M52주_최고가일.After(당일.Add(-380*lib.P1일)))
	lib.F테스트_참임(t, 값.M52주_최고가일.Before(당일.Add(2*lib.P1일)), 값.M52주_최고가일, 당일) // 당일 주문의 마지막 결제일은 +3일이라서 그런가? 희한하네.
	lib.F테스트_참임(t, 값.M52주_최저가일.After(당일.Add(-380*lib.P1일)), 값.M52주_최저가일, 당일.Add(-62*lib.P1일))
	lib.F테스트_참임(t, 값.M52주_최저가일.Before(당일.Add(2*lib.P1일)))
	lib.F테스트_참임(t, 값.M소진율 >= 0.0 && 값.M소진율 <= 100.0, 값.M소진율)
	//lib.F문자열_출력("값.PER : %v", 값.PER)
	//lib.F문자열_출력("값.PBR : %v", 값.PBR)
	lib.F테스트_참임(t, 값.M상장주식수_천 > 0, 값.M상장주식수_천)
	lib.F테스트_참임(t, 값.M증거금율 >= 0 && 값.M증거금율 <= 100, 값.M증거금율)
	lib.F테스트_같음(t, 값.M수량단위, 1) // 단주 거래 전면 허용되었다고 하던 데.
	lib.F테스트_참임(t, 값.M회전율 >= 0, 값.M회전율)
	lib.F테스트_같음(t, len(값.M종목코드), 6)
	lib.F테스트_참임(t, 값.M거래대금_백만 >= 0, 값.M거래대금_백만)
	lib.F테스트_참임(t, 값.M전일동시간거래량 >= 0, 값.M전일동시간거래량)
	lib.F테스트_참임(t, 값.M연중_최고가 > 0)
	lib.F테스트_같음(t, 값.M연중_최고가_일자.Year(), time.Now().Year(), time.Now().Year()-1)
	lib.F테스트_참임(t, 값.M연중_최저가 > 0)
	lib.F테스트_같음(t, 값.M연중_최저가_일자.Year(), time.Now().Year(), time.Now().Year()-1)
	lib.F테스트_참임(t, 값.M목표가 >= 0, 값.M목표가)

	if xing.ETF_ETN_종목_여부(값.M종목코드) {
		lib.F테스트_같음(t, 값.M자본금_억, 0)
		lib.F테스트_같음(t, 값.M액면가, 0)
		lib.F테스트_같음(t, 값.M전분기_매출액_억, 0)
		lib.F테스트_같음(t, 값.M전전분기_매출액, 0)
		lib.F테스트_같음(t, 값.M전년대비_매출액_증감율, 0)
		//lib.F테스트_같음(t, 값.M발행가격, 0)
		lib.F테스트_같음(t, 값.M결산월, 0)
	} else {
		lib.F테스트_참임(t, 값.M자본금_억 >= 0, 값.M종목코드, 값.M자본금_억)
		lib.F테스트_참임(t, 값.M액면가 >= 0, 값.M종목코드, 값.M액면가) // 완리 (900180)는 액면가 0임
		lib.F테스트_참임(t, 값.M전분기_매출액_억 >= 0)            // '동북아 12호(083370)'의 경우 대여업만 하므로 (판매) 매출액 0임.
		lib.F테스트_참임(t, 값.M전전분기_매출액 >= 0)
		//lib.F테스트_참임(t, 값.M전년대비_매출액_증감율 > 0)
		//lib.F테스트_참임(t, 값.M발행가격 >= 0, 종목코드, 값.M발행가격)   // 발행가격이 0인 종목이 존재함. 이해불가.

		lib.F중복없는_문자열_출력("t1305 결산월 관련 테스트 보류")
		//lib.F테스트_같음(t, 값.M결산월, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
	}

	lib.F테스트_참임(t, 값.M유동주식수_천 > 0)

	오차 := lib.F절대값_실수((float64(값.M대용가) - float64(값.M기준가)*float64(값.M증거금율)/100) / float64(값.M대용가))
	lib.F테스트_참임(t, 오차 < 3, "오차:%v, 기준가:%v, 증거금율:%v, 대용가:%v", 오차, 값.M기준가, 값.M증거금율, 값.M대용가)

	시가총액 := 값.M시가총액_억 * 100000000
	상장주식수 := 값.M상장주식수_천 * 1000
	오차율 := lib.F절대값_실수((시가총액-값.M현재가*상장주식수)/시가총액) / 100
	lib.F테스트_참임(t, 오차율 < 10, 오차율)
	lib.F테스트_참임(t, 값.M상장일.After(time.Time{})) // 1900-01-01 이후
	lib.F테스트_참임(t, 값.M전분기명 == "" ||
		lib.F정규식_검색(값.M전분기명, []string{"[0-9]+ [1-4]분기"}) != "" ||
		lib.F정규식_검색(값.M전분기명, []string{"[0-9]+ 결산"}) != "", 값.M전분기명)

	//lib.F테스트_참임(t, 값.M전분기_영업이익_억 ???)
	//lib.F테스트_참임(t, 값.M전분기_경상이익_억 ???)
	//lib.F테스트_참임(t, 값.M전분기_순이익_억 ???)
	lib.F테스트_참임(t, float64(값.M전분기_순이익_억)*값.M전분기EPS >= 0, 값.M전분기_순이익_억, 값.M전분기EPS)
	lib.F테스트_참임(t, 값.M전전분기명 == "" ||
		lib.F정규식_검색(값.M전전분기명, []string{"[0-9]+ [1-4]분기"}) != "", 값.M전전분기명) // "[0-9]+ 결산"

	//lib.F테스트_참임(t, 값.M전전분기_영업이익 ???)
	//lib.F테스트_참임(t, 값.M전전분기_경상이익 ???)
	//lib.F테스트_참임(t, 값.M전전분기_순이익 ???)
	lib.F테스트_참임(t, float64(값.M전전분기_순이익)*값.M전전분기EPS >= 0, 값.M전전분기_순이익, 값.M전전분기EPS)

	//lib.F테스트_참임(t, 값.M전년대비_영업이익_증감율 ???)
	//lib.F테스트_참임(t, 값.M전년대비_경상이익_증감율 ???)
	//lib.F테스트_참임(t, 값.M전년대비_순이익_증감율 ???)

	// 주식소각, 주식분할등 주식수량에 변동이 있는 경우, EPS와 순이익의 방향성이 다를 수 있다.
	//lib.F테스트_참임(t, float64(값.M전년대비_순이익_증감율) * 값.M전년대비_EPS_증감율 >= 0, 종목코드, 값.M전년대비_순이익_증감율, 값.M전년대비_EPS_증감율)

	lib.F테스트_같음(t, 값.M락구분, "", "권배락", "권리락", "배당락", "액면분할", "액면병합", "주식병합", "기업분할", "감자")
	lib.F테스트_같음(t, 값.M관리_급등구분, "", "관리/경고", "관리/위험", "관리", "예고", "경고", "위험")
	lib.F테스트_같음(t, 값.M정지_연장구분, "", "거래정지", "거래중단", "시가연장", "종가연장")
	//lib.F변수값_확인(값.M투자_불성실구분) // ??
	lib.F테스트_같음(t, 값.M시장구분, lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥)
	//lib.F변수값_확인(값.T_PER) // ??
	lib.F테스트_같음(t, 값.M통화ISO코드, "KRW")
	//lib.F변수값_확인(값.M투자주의환기)     // ??
	//lib.F변수값_확인(값.M기업인수목적회사여부) // ??
	//lib.F변수값_확인(값.M배분적용구분코드)   // ??
	//lib.F변수값_확인(값.M배분적용구분)     // ??
	//lib.F변수값_확인(값.M단기과열_VI발동)  // ??

	예상_M정적VI상한가 := int64(float64(값.M현재가) * 1.1)
	lib.F테스트_참임(t, lib.F오차율_퍼센트(값.M정적VI상한가, 예상_M정적VI상한가) < 10 ||
		lib.F오차(값.M정적VI상한가, 예상_M정적VI상한가) < 50)

	예상_M정적VI하한가 := int64(float64(값.M현재가) * 0.9)
	lib.F테스트_참임(t, lib.F오차율_퍼센트(값.M정적VI하한가, 예상_M정적VI하한가) < 10 ||
		lib.F오차(값.M정적VI하한가, 예상_M정적VI하한가) < 50)

	lib.F테스트_같음(t, len(값.M매도_거래원_정보_모음), 5)
	lib.F테스트_같음(t, len(값.M매수_거래원_정보_모음), 5)

	for _, 매도_거래원_정보 := range 값.M매도_거래원_정보_모음 {
		lib.F테스트_참임(t, 매도_거래원_정보.M증권사_코드 != "")
		lib.F테스트_참임(t, 매도_거래원_정보.M이름 != "")
		lib.F테스트_참임(t, 매도_거래원_정보.M거래_수량 >= 0)
		lib.F테스트_참임(t, 매도_거래원_정보.M평균_단가 >= 0)
		lib.F테스트_참임(t, 매도_거래원_정보.M거래_대금 >= 0)
		//lib.F테스트_참임(t, 매도_거래원_정보.M전일대비_증감 ??)
		lib.F테스트_참임(t, 매도_거래원_정보.M비율 >= 0)
	}

	for _, 매수_거래원_정보 := range 값.M매수_거래원_정보_모음 {
		lib.F테스트_참임(t, 매수_거래원_정보.M증권사_코드 != "")
		lib.F테스트_참임(t, 매수_거래원_정보.M이름 != "")
		lib.F테스트_참임(t, 매수_거래원_정보.M거래_수량 >= 0)
		lib.F테스트_참임(t, 매수_거래원_정보.M평균_단가 >= 0)
		lib.F테스트_참임(t, 매수_거래원_정보.M거래_대금 >= 0)
		//lib.F테스트_참임(t, 매수_거래원_정보.M전일대비_증감 ??)
		lib.F테스트_참임(t, 매수_거래원_정보.M비율 >= 0)
	}

	lib.F테스트_참임(t, 값.M외국계_매도_거래원_정보.M거래_수량 >= 0)
	lib.F테스트_참임(t, 값.M외국계_매도_거래원_정보.M평균_단가 >= 0)
	lib.F테스트_참임(t, 값.M외국계_매도_거래원_정보.M거래_대금 >= 0)
	//lib.F테스트_참임(t, 값.M외국계_매도_거래원_정보.M전일대비_증감 ??)
	lib.F테스트_참임(t, 값.M외국계_매도_거래원_정보.M비율 >= 0)

	lib.F테스트_참임(t, 값.M외국계_매수_거래원_정보.M거래_수량 >= 0)
	lib.F테스트_참임(t, 값.M외국계_매수_거래원_정보.M평균_단가 >= 0)
	lib.F테스트_참임(t, 값.M외국계_매수_거래원_정보.M거래_대금 >= 0)
	//lib.F테스트_참임(t, 값.M외국계_매수_거래원_정보.M전일대비_증감 ??)
	lib.F테스트_참임(t, 값.M외국계_매수_거래원_정보.M비율 >= 0)
}

func TestT1305_기간별_주가_조회(t *testing.T) {
	t.Parallel()

	종목코드 := "069500"
	일주월_구분 := ([]xt.T일주월_구분{xt.P일주월_일, xt.P일주월_주, xt.P일주월_월})[lib.F임의_범위_이내_정수값(0, 2)]
	var 이전_일자 time.Time

	값_모음, 에러 := xing.TrT1305_기간별_주가_조회(종목코드, 일주월_구분, 300)
	lib.F테스트_에러없음(t, 에러)

	lib.F테스트_참임(t, len(값_모음) > 250, len(값_모음))

	for i, 값 := range 값_모음 {
		lib.F테스트_같음(t, 종목코드, 값.M종목코드)
		lib.F테스트_같음(t, 값.M일자.Hour(), 0)
		lib.F테스트_같음(t, 값.M일자.Minute(), 0)
		lib.F테스트_같음(t, 값.M일자.Second(), 0)
		lib.F테스트_같음(t, 값.M일자.Nanosecond(), 0)
		lib.F테스트_참임(t, 값.M일자.After(이전_일자) || 값.M일자.Equal(이전_일자))
		이전_일자 = 값.M일자

		if i > 0 {
			차이 := lib.F절대값_실수(값.M일자.Sub(값_모음[i-1].M일자).Hours() / 24)

			switch 일주월_구분 {
			case xt.P일주월_일:
				lib.F테스트_참임(t, 차이 >= 1 && 차이 < 13, 종목코드, 값_모음[i-1].M일자, 값.M일자, 차이)
			case xt.P일주월_주:
				lib.F테스트_참임(t, 차이 >= 3 && 차이 < 20, 종목코드, 값_모음[i-1].M일자, 값.M일자, 차이)
			case xt.P일주월_월:
				lib.F테스트_참임(t, 차이 >= 20 && 차이 < 45, 종목코드, 값_모음[i-1].M일자, 값.M일자, 차이)
			default:
				panic(lib.New에러("예상하지 못한 일주월 구분값 : '%v'", 일주월_구분))
			}
		}

		if 값.M고가 > 0 {
			lib.F테스트_참임(t, 값.M고가 >= 값.M시가, 값.M종목코드, 값.M고가, 값.M시가)
			lib.F테스트_참임(t, 값.M고가 >= 값.M종가, 값.M종목코드, 값.M고가, 값.M종가)
			lib.F테스트_참임(t, 값.M고가 >= 값.M저가, 값.M종목코드, 값.M고가, 값.M저가)
			lib.F테스트_참임(t, 값.M저가 <= 값.M시가, 값.M종목코드, 값.M저가, 값.M시가)
			lib.F테스트_참임(t, 값.M저가 <= 값.M종가, 값.M종목코드, 값.M저가, 값.M종가)
		}

		// 저가 한계값에 대한 추정에 자신이 없어서 일단 건너뜀.
		//최소_호가단위, 에러 := lib.F최소_호가단위by종목코드(값.M종목코드)
		//lib.F테스트_에러없음(t, 에러)
		//저가_한계 :=  int64(float64(값.M고가 - 최소_호가단위) * 0.7) - 최소_호가단위
		//lib.F테스트_참임(t, 값.M저가 >= 저가_한계, 값.M저가, 저가_한계)

		switch 값.M전일대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M전일대비등락폭 > 0)
			lib.F테스트_참임(t, 값.M전일대비등락율 >= 0, 값.M전일대비구분, 값.M전일대비등락율)
		case xt.P구분_보합:
			lib.F테스트_같음(t, 값.M전일대비등락폭, 0)
			lib.F테스트_같음(t, 값.M전일대비등락율, 0)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M전일대비등락폭 < 0,
				"종목코드 : '%v', 구분 : '%v', 등락폭 : '%v'",
				종목코드, 값.M전일대비구분, 값.M전일대비등락폭)

			lib.F테스트_참임(t, 값.M전일대비등락율 <= 0,
				"종목코드 : '%v', 구분 : '%v', 등락율 : '%v'",
				종목코드, 값.M전일대비구분, 값.M전일대비등락율)
		default:
			if lib.F2정수64_단순형(값.M전일대비등락폭) == 0 &&
				lib.F2실수_단순형(값.M전일대비등락율) == 0.0 {
				값.M전일대비구분 = xt.P구분_보합
			} else {
				lib.F문자열_출력("일주월 구분 : '%v', 종목코드 : '%v', 일자 : '%v', 전일대비구분 : '%v'",
					일주월_구분, 값.M종목코드, 값.M일자.Format(lib.P일자_형식), 값.M전일대비구분)
				t.FailNow()
			}
		}

		switch 값.M시가대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M시가대비등락폭 > 0)
			lib.F테스트_참임(t, 값.M시가대비등락율 >= 0)
		case xt.P구분_보합:
			lib.F테스트_참임(t, 값.M시가대비등락폭 == 0)
			lib.F테스트_참임(t, 값.M시가대비등락율 == 0)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M시가대비등락폭 < 0)
			lib.F테스트_참임(t, 값.M시가대비등락율 <= 0)
		default:
			lib.F문자열_출력("일주월 구분 : '%v', 종목코드 : '%v', 일자 : '%v', 시가대비구분 : '%v'",
				일주월_구분, 값.M종목코드, 값.M일자, 값.M시가대비구분)
			t.FailNow()
		}

		switch 값.M고가대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M고가대비등락폭 > 0)
			lib.F테스트_참임(t, 값.M고가대비등락율 > 0)
		case xt.P구분_보합:
			lib.F테스트_참임(t, 값.M고가대비등락폭 == 0)
			lib.F테스트_참임(t, 값.M고가대비등락율 == 0)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M고가대비등락폭 < 0)
			lib.F테스트_참임(t, 값.M고가대비등락율 < 0)
		default:
			lib.F문자열_출력("일주월 구분 : '%v', 종목코드 : '%v', 일자 : '%v', 고가대비구분 : '%v'",
				일주월_구분, 값.M종목코드, 값.M일자, 값.M고가대비구분)
			t.FailNow()
		}

		switch 값.M저가대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M저가대비등락폭 > 0)
			lib.F테스트_참임(t, 값.M저가대비등락율 > 0)
		case xt.P구분_보합:
			lib.F테스트_참임(t, 값.M저가대비등락폭 == 0)
			lib.F테스트_참임(t, 값.M저가대비등락율 == 0)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M저가대비등락폭 < 0)
			lib.F테스트_참임(t, 값.M저가대비등락율 < 0)
		default:
			lib.F문자열_출력("일주월 구분 : '%v', 종목코드 : '%v', 일자 : '%v', 저가대비구분 : '%v'",
				일주월_구분, 값.M종목코드, 값.M일자, 값.M저가대비구분)
			t.FailNow()
		}

		lib.F테스트_참임(t, 값.M거래량 >= 0)
		lib.F테스트_참임(t, 값.M거래대금_백만 >= 0)
		//lib.F테스트_참임(t, 값.M거래_증가율)
		lib.F테스트_참임(t, 값.M체결강도 >= 0)
		lib.F테스트_참임(t, 값.M소진율 >= 0)
		lib.F테스트_참임(t, 값.M회전율 >= 0)
		//lib.F테스트_참임(t, 값.M외국인_순매수)
		//lib.F테스트_참임(t, 값.M기관_순매수)
		//lib.F테스트_참임(t, 값.M개인_순매수)
		lib.F테스트_참임(t, 값.M시가총액_백만 > 0)
	}
}

func TestT1310_현물_당일전일_분틱_조회(t *testing.T) {
	t.Parallel()

	종목코드 := xing.F임의_종목().G코드()
	당일전일_구분 := ([]xt.T당일전일_구분{xt.P당일전일구분_당일, xt.P당일전일구분_전일})[lib.F임의_범위_이내_정수값(0, 1)]
	분틱_구분 := ([]xt.T분틱_구분{xt.P분틱구분_분, xt.P분틱구분_틱})[lib.F임의_범위_이내_정수값(0, 1)]
	var 종료시각 time.Time

	if 당일전일_구분 == xt.P당일전일구분_당일 {
		종료시각 = lib.F2일자별_시각_단순형(xing.F당일(), "15:04:05", "00:00:00")
		종료시각 = 종료시각.AddDate(0, 0, 1).Add(-1 * lib.P1초)
	} else {
		종료시각 = lib.F2일자별_시각_단순형(xing.F전일(), "15:04:05", "00:00:00").Add(-1 * lib.P1초)
	}

	값_모음, 에러 := xing.TrT1310_현물_당일전일_분틱_조회(종목코드, 당일전일_구분, 분틱_구분, 종료시각, 70)
	lib.F테스트_에러없음(t, 에러)

	const 일자_포맷_문자열 = "2006/01/02"

	for _, 값 := range 값_모음 {
		switch 당일전일_구분 {
		case xt.P당일전일구분_당일:
			lib.F테스트_참임(t, lib.F2일자(값.M시각).Equal(xing.F당일()), 값.M시각, xing.F당일())
		case xt.P당일전일구분_전일:
			lib.F테스트_참임(t, lib.F2일자(값.M시각).Equal(xing.F전일()), 값.M시각, xing.F전일())
		default:
			panic(lib.New에러("예상하지 못한 경우. '%v'", 값.M시각))
		}

		lib.F테스트_참임(t, 값.M시각.After(종료시각.AddDate(0, 0, -1)))
		lib.F테스트_참임(t, 값.M시각.Before(종료시각.Add(lib.P3분)), 값.M시각, 종료시각.Add(lib.P3분))

		lib.F테스트_참임(t, 값.M현재가 > 0)
		lib.F테스트_같음(t, 값.M전일대비구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)

		switch 값.M전일대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M전일대비등락폭 > 0)
			lib.F테스트_참임(t, 값.M전일대비등락율 > 0)
			lib.F테스트_참임(t, 값.M전일대비등락율 < 30)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M전일대비등락폭 < 0,
				값.M전일대비구분, uint8(값.M전일대비구분), 값.M전일대비등락폭, 값)
			lib.F테스트_참임(t, 값.M전일대비등락율 < 0,
				값.M전일대비구분, 값.M전일대비등락율)
			lib.F테스트_참임(t, 값.M전일대비등락율 > -30,
				값.M전일대비구분, 값.M전일대비등락율)
		case xt.P구분_보합:
			lib.F테스트_같음(t, 값.M전일대비등락폭, 0)
			lib.F테스트_참임(t, 값.M전일대비등락율 < 1)
		default:
			panic("예상하지 못한 경우.")
		}

		lib.F테스트_참임(t, 값.M체결수량 >= 0)

		// 게시판 답변 : 체결강도 = 매수체결량/매도체결량*100 입니다.
		if 값.M매도체결수량 != 0 {
			체결강도_예상값 := float64(값.M매수체결수량) / float64(값.M매도체결수량) * 100

			lib.F테스트_참임(t,
				lib.F오차(값.M체결강도, 체결강도_예상값) < 0.01 ||
					lib.F오차율_퍼센트(값.M체결강도, 체결강도_예상값) < 3,
				값.M체결강도, 체결강도_예상값,
				값.M매수체결수량,
				값.M매도체결수량)
		}

		lib.F테스트_참임(t, 값.M거래량 >= 0)

		if 값.M매도체결수량 > 0 {
			lib.F테스트_참임(t, 값.M매도체결건수 > 0)
		}

		if 값.M매도체결건수 > 0 {
			lib.F테스트_참임(t, 값.M매도체결수량 > 0)
		}

		if 값.M매수체결수량 > 0 {
			lib.F테스트_참임(t, 값.M매수체결건수 > 0)
		}

		if 값.M매수체결건수 > 0 {
			lib.F테스트_참임(t, 값.M매수체결수량 > 0)
		}

		lib.F테스트_같음(t, 값.M순체결량, 값.M매수체결수량-값.M매도체결수량)
		lib.F테스트_같음(t, 값.M순체결건수, 값.M매수체결건수-값.M매도체결건수)
	}
}

func TestT1404_관리_종목(t *testing.T) {
	t.Parallel()

	시장_구분_모음 := []lib.T시장구분{lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥}
	시장_구분 := 시장_구분_모음[lib.F임의_범위_이내_정수값(0, len(시장_구분_모음)-1)]

	관리_질의_구분_모음 := []xt.T관리_질의_구분{xt.P구분_관리, xt.P구분_불성실_공시, xt.P구분_투자_유의, xt.P구분_투자_환기}
	관리_질의_구분 := 관리_질의_구분_모음[lib.F임의_범위_이내_정수값(0, len(관리_질의_구분_모음)-1)]

	값_모음, 에러 := xing.TrT1404_관리종목_조회(시장_구분, 관리_질의_구분)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		//lib.F테스트_참임(t, F종목코드_존재함(값.M종목코드), 값.M종목코드, 값.M종목명)	// 상장폐지된 경우에는 종목코드가 존재하지 않음.
		lib.F테스트_다름(t, 값.M종목명, "")
		lib.F테스트_참임(t, 값.M현재가 >= 0)
		lib.F테스트_에러없음(t, 값.M전일대비구분.G검사())
		lib.F테스트_같음(t, 값.M전일대비_등락폭, 값.M전일대비구분.G부호보정_정수64(값.M전일대비_등락폭))
		lib.F테스트_같음(t, 값.M전일대비_등락율, 값.M전일대비구분.G부호보정_실수64(값.M전일대비_등락율))
		lib.F테스트_참임(t, 값.M거래량 >= 0)
		lib.F테스트_참임(t, 값.M지정일_주가 > 0)
		//lib.F테스트_같음(t, 값.M지정일_대비_등락폭, 값.M현재가-값.M지정일_주가)

		//예상_등락율 := float64(값.M현재가-값.M지정일_주가) / float64(값.M지정일_주가) * 100
		//lib.F테스트_참임(t, lib.F오차율_퍼센트(값.M지정일_대비_등락율, 예상_등락율) < 10,
		//	값.M종목코드, 값.M종목명, 값.M지정일_주가, 값.M현재가, 값.M지정일_대비_등락폭, 값.M지정일_대비_등락율, 예상_등락율)
		lib.F테스트_다름(t, 값.M사유, "")
		lib.F테스트_참임(t, 값.M지정일.After(lib.F금일().AddDate(-30, 0, 0)))
		lib.F테스트_참임(t, 값.M해제일.Equal(time.Time{}) || 값.M해제일.After(lib.F금일().AddDate(-30, 0, 0)))
	}
}

func TestT1405_투자_경고_종목(t *testing.T) {
	t.Parallel()

	시장_구분_모음 := []lib.T시장구분{lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥}
	시장_구분 := 시장_구분_모음[lib.F임의_범위_이내_정수값(0, len(시장_구분_모음)-1)]

	투자경고_질의_구분_모음 := []xt.T투자경고_질의_구분{xt.P투자경고, xt.P매매정지, xt.P정리매매, xt.P투자주의, xt.P투자위험, xt.P위험예고, xt.P단기과열지정, xt.P단기과열지정예고}
	투자경고_질의_구분 := 투자경고_질의_구분_모음[lib.F임의_범위_이내_정수값(0, len(투자경고_질의_구분_모음)-1)]

	값_모음, 에러 := xing.TrT1405_투자경고_조회(시장_구분, 투자경고_질의_구분)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		//lib.F테스트_참임(t, F종목코드_존재함(값.M종목코드), 값.M종목코드, 값.M종목명)	// 상장폐지된 경우에는 종목코드가 존재하지 않음.
		lib.F테스트_다름(t, 값.M종목명, "")
		lib.F테스트_참임(t, 값.M현재가 >= 0)
		lib.F테스트_에러없음(t, 값.M전일대비구분.G검사())
		lib.F테스트_같음(t, 값.M전일대비_등락폭, 값.M전일대비구분.G부호보정_정수64(값.M전일대비_등락폭))
		lib.F테스트_같음(t, 값.M전일대비_등락율, 값.M전일대비구분.G부호보정_실수64(값.M전일대비_등락율))
		lib.F테스트_참임(t, 값.M거래량 >= 0)
		lib.F테스트_참임(t, 값.M지정일.After(lib.F금일().AddDate(-30, 0, 0)), 값.M지정일)
		lib.F테스트_참임(t, 값.M해제일.Equal(time.Time{}) || 값.M해제일.After(lib.F금일().AddDate(-30, 0, 0)))
	}
}

func TestT1902_ETF_시간별_추이(t *testing.T) {
	t.Parallel()

	지금 := lib.F지금()

	if 지금.Hour() >= 5 && 지금.Hour() < 9 {
		t.SkipNow() // 이 시간대에 테스트 에러가 발생함.
	}

	종목코드 := "069500" // 코덱스200

	값_모음, 에러 := xing.TrT1902_ETF_시간별_추이(종목코드, 100)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_다름(t, len(값_모음), 0)

	당일 := xing.F당일()

	초기값 := time.Time{}
	이전_시각 := 초기값

	for _, 값 := range 값_모음 {
		lib.F테스트_같음(t, 값.M시각.Year(), 당일.Year())
		lib.F테스트_같음(t, 값.M시각.Month(), 당일.Month())
		lib.F테스트_같음(t, 값.M시각.Day(), 당일.Day())
		lib.F테스트_같음(t, 값.M시각.Second()%10, 0) // 10초 마다 한 번씩 옴.
		if 이전_시각 != 초기값 {
			lib.F테스트_참임(t, 값.M시각.After(이전_시각), 값.M시각, 이전_시각)
			lib.F테스트_같음(t, 값.M시각.Sub(이전_시각), lib.P10초)
		}
		이전_시각 = 값.M시각
		lib.F테스트_참임(t, 값.M현재가 > 0)
		lib.F테스트_같음(t, 값.M전일대비구분,
			xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)

		switch 값.M전일대비구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M전일대비등락폭 > 0)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M전일대비등락폭 < 0,
				값.M전일대비구분, 값.M전일대비등락폭, 값)
		case xt.P구분_보합:
			lib.F테스트_같음(t, 값.M전일대비등락폭, 0)
		default:
			lib.F문자열_출력("예상하지 못한 구분값 : '%v'", 값.M전일대비구분)
			t.FailNow()
		}

		lib.F테스트_참임(t, 값.M누적_거래량 >= 0)
		//lib.F변수값_확인(응답_반복값.M현재가_NAV_차이)   // +- 부호 자체적으로 구분됨.
		lib.F테스트_참임(t, 값.NAV > 0)
		//lib.F변수값_확인(응답_반복값.NAV전일대비등락폭)   // +- 부호 자체적으로 구분됨.
		//lib.F변수값_확인(응답_반복값.M추적오차)   // +- 부호 자체적으로 구분됨.
		//lib.F변수값_확인(응답_반복값.M괴리율)   // +- 부호 자체적으로 구분됨.
		lib.F테스트_참임(t, 값.M지수 >= 0, 종목코드, 값.M지수)
		lib.F테스트_참임(t, float64(값.M지수_전일대비등락폭)*값.M지수_전일대비등락율 >= 0,
			값.M지수_전일대비등락폭, 값.M지수_전일대비등락율)
		//lib.F변수값_확인(응답_반복값.M지수_전일대비등락폭)   // +- 부호 자체적으로 구분됨.
		//lib.F변수값_확인(응답_반복값.M지수_전일대비등락율)   // +- 부호 자체적으로 구분됨.
	}
}

func TestT1906_ETF_LP_호가_조회(t *testing.T) {
	t.Parallel()

	const 종목코드 = "069500" // 코덱스200

	값, 에러 := xing.TrT1906_ETF_LP_호가_조회(종목코드)
	lib.F테스트_에러없음(t, 에러)

	lib.F테스트_다름(t, 값.M종목명, "")
	lib.F테스트_참임(t, 값.M현재가 >= 0)
	lib.F테스트_같음(t, 값.M전일대비구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
	lib.F테스트_참임(t, 값.M전일대비등락폭 >= 0)

	switch 값.M전일대비구분 { // 등락율 확인
	case xt.P구분_상한, xt.P구분_상승:
		lib.F테스트_참임(t, 값.M등락율 >= 0)
	case xt.P구분_하한, xt.P구분_하락:
		lib.F테스트_참임(t, 값.M등락율 <= 0)
	case xt.P구분_보합:
		lib.F테스트_같음(t, 값.M등락율, 0)
	}

	lib.F테스트_참임(t, 값.M거래량 >= 0)
	lib.F테스트_참임(t, 값.M전일종가 >= 0)
	lib.F테스트_같음(t, len(값.M매도_호가_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_호가_모음), 10)
	lib.F테스트_같음(t, len(값.M매도_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.LP매도_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.LP매수_잔량_모음), 10)
	lib.F테스트_같음(t, len(값.M매도_직전대비수량_모음), 10)
	lib.F테스트_같음(t, len(값.M매수_직전대비수량_모음), 10)

	var 매도호가수량합, 매수호가수량합 int64

	for i := 0; i < 10; i++ {
		lib.F테스트_참임(t, 값.M매도_호가_모음[i] >= 0, 값.M매도_호가_모음[i])
		lib.F테스트_참임(t, 값.M매수_호가_모음[i] >= 0, 값.M매수_호가_모음[i])
		lib.F테스트_참임(t, 값.M매도_잔량_모음[i] >= 0, 값.M매도_잔량_모음[i])
		lib.F테스트_참임(t, 값.M매수_잔량_모음[i] >= 0, 값.M매수_잔량_모음[i])
		lib.F테스트_참임(t, 값.LP매도_잔량_모음[i] >= 0, 값.M매도_잔량_모음[i])
		lib.F테스트_참임(t, 값.LP매수_잔량_모음[i] >= 0, 값.M매수_잔량_모음[i])

		// (-) 값이 나오더라..
		//lib.F테스트_참임(t, 값.M매도_직전대비수량_모음[i] >= 0, 값.M매도_직전대비수량_모음[i])
		//lib.F테스트_참임(t, 값.M매수_직전대비수량_모음[i] >= 0, 값.M매수_직전대비수량_모음[i])

		매도호가수량합 = 매도호가수량합 + 값.M매도_잔량_모음[i]
		매수호가수량합 = 매수호가수량합 + 값.M매수_잔량_모음[i]
	}

	if xing.F금일_한국증시_개장() && krx.F한국증시_정규_거래_시간임() {
		lib.F테스트_참임(t, 값.M시각.After(time.Now().Add(-1*lib.P10분)),
			값.M시각.Format("15:04:06"), time.Now().Add(-1*lib.P10분).Format("15:04:06"))
		lib.F테스트_참임(t, 값.M시각.Before(time.Now().Add(lib.P10분)),
			time.Now().Add(lib.P10분).Format("15:04:06"), 값.M시각.Format("15:04:06"))
	}

	if 값.M예상체결가격 != 0 {
		lib.F테스트_참임(t, float64(값.M예상체결가격) >= float64(값.M현재가)*0.7)
		lib.F테스트_참임(t, float64(값.M예상체결가격) <= float64(값.M현재가)*1.3)
		lib.F테스트_참임(t, 값.M예상체결수량 >= 0)
	}

	lib.F테스트_같음(t, 값.M예상체결전일구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
	lib.F테스트_참임(t, 값.M예상체결전일대비 >= 0)

	switch 값.M예상체결전일구분 { // 예상 체결 등락율 확인
	case xt.P구분_상한, xt.P구분_상승:
		lib.F테스트_참임(t, 값.M예상체결등락율 >= 0)
	case xt.P구분_하한, xt.P구분_하락:
		lib.F테스트_참임(t, 값.M예상체결등락율 <= 0)
	case xt.P구분_보합:
		lib.F테스트_같음(t, 값.M예상체결등락율, 0)
	}

	lib.F테스트_참임(t, 값.M시간외매도잔량 >= 0)
	lib.F테스트_참임(t, 값.M시간외매수잔량 >= 0)
	lib.F테스트_같음(t, 값.M동시호가_구분, xt.P동시호가_아님, xt.P동시호가_장중, xt.P동시호가_시간외, xt.P동시호가_동시)
	lib.F테스트_같음(t, len(값.M종목코드), 6)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M현재가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M하한가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M고가)
	lib.F테스트_참임(t, 값.M상한가 >= 값.M저가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M현재가)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M시가 || 값.M시가 == 0)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M고가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M하한가 <= 값.M저가 || 값.M저가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M현재가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M시가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M고가 >= 값.M저가 || 값.M고가 == 0)
	lib.F테스트_참임(t, 값.M저가 <= 값.M현재가)
}

func TestT3341_재무_순위_종합(t *testing.T) {
	t.Parallel()

	시장구분_모음 := []lib.T시장구분{lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥}
	시장구분 := 시장구분_모음[lib.F임의_범위_이내_정수값(0, 2)]

	재무순위_구분_모음 := []xt.T재무순위_구분{xt.P재무순위_매출액증가율,
		xt.P재무순위_영업이익증가율, xt.P재무순위_세전계속이익증가율, xt.P재무순위_부채비율,
		xt.P재무순위_유보율, xt.P재무순위_EPS, xt.P재무순위_BPS, xt.P재무순위_ROE,
		xt.P재무순위_PER, xt.P재무순위_PBR, xt.P재무순위_PEG}
	재무순위_구분 := 재무순위_구분_모음[lib.F임의_범위_이내_정수값(0, len(재무순위_구분_모음)-1)]

	const 수량 = 100
	실수값 := lib.F2실수_단순형

	값_모음, 에러 := xing.TrT3341_재무_순위_종합(시장구분, 재무순위_구분, 수량)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, 값.M순위 > 0 && 값.M순위 <= 수량)
		lib.F테스트_참임(t, xing.F종목코드_존재함(값.M종목코드))
		lib.F테스트_참임(t, strings.TrimSpace(값.M기업명) != "")
		//lib.F테스트_참임(t, math.Abs(실수값(값.M매출액_증가율)) < 10000, 값.M종목코드, 값.M매출액_증가율)
		//lib.F테스트_참임(t, math.Abs(실수값(값.M영업이익_증가율)) < 10000, 값.M종목코드, 값.M영업이익_증가율)
		//lib.F테스트_참임(t, math.Abs(실수값(값.M경상이익_증가율)) < 10000, 값.M종목코드, 값.M경상이익_증가율)
		//lib.F테스트_참임(t, 실수값(값.M부채비율) >= 0 && 실수값(값.M부채비율) < 10000, 값.M종목코드, 실수값(값.M부채비율))
		lib.F테스트_참임(t, 실수값(값.M부채비율) < 10000, 값.M종목코드, 실수값(값.M부채비율))
		//lib.F테스트_참임(t, 실수값(값.M유보율) >= 0)
		lib.F테스트_참임(t, 실수값(값.EPS)*실수값(값.PER) >= 0)
		lib.F테스트_참임(t, 실수값(값.EPS)*실수값(값.ROE) >= 0)
		lib.F테스트_참임(t, 실수값(값.BPS) > 0)
		lib.F테스트_참임(t, math.Abs(실수값(값.ROE)) < 100000, 값.M종목코드, 값.ROE)
		lib.F테스트_참임(t, math.Abs(실수값(값.PER)) < 100000, 값.M종목코드, 값.PER)
		lib.F테스트_참임(t, math.Abs(실수값(값.PBR)) < 100000, 값.M종목코드, 값.PBR)
		lib.F테스트_참임(t, math.Abs(실수값(값.PEG)) < 100000, 값.M종목코드, 값.PEG)
	}
}

func TestT8407_F현물_멀티_현재가_조회(t *testing.T) {
	t.Parallel()

	종목코드_모음 := lib.F종목코드_추출(lib.F샘플_종목_모음_전체(), lib.F임의_범위_이내_정수값(40, 110))
	응답값_맵, 에러 := xing.TrT8407_현물_멀티_현재가_조회(종목코드_모음)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_같음(t, len(응답값_맵), len(종목코드_모음))

	testT8407_F현물_멀티_현재가_조회_반복값_도우미(t, 응답값_맵)
}

func testT8407_F현물_멀티_현재가_조회_반복값_도우미(t *testing.T,
	응답값_맵 map[string]*xt.T8407_현물_멀티_현재가_조회_응답) {

	for 종목코드, 값 := range 응답값_맵 {
		lib.F테스트_같음(t, 값.M종목코드, 종목코드)
		lib.F테스트_다름(t, 값.M종목명, "")
		lib.F테스트_참임(t, 값.M현재가 > 0, 값.M현재가)
		lib.F테스트_에러없음(t, 값.M전일종가대비구분.G검사())
		lib.F테스트_참임(t, 값.M누적_거래량 >= 0, 값.M종목코드, 값.M누적_거래량)
		lib.F테스트_참임(t, 값.M매도호가 >= 0, 값.M종목코드, 값.M매도호가)
		lib.F테스트_참임(t, 값.M매수호가 >= 0, 값.M종목코드, 값.M매수호가)
		lib.F테스트_참임(t, 값.M체결수량 >= 0)
		lib.F테스트_참임(t, 값.M체결강도 >= 0, 값.M종목코드, 값.M체결강도)
		lib.F테스트_참임(t, 값.M현재가 >= 값.M저가)
		lib.F테스트_참임(t, 값.M시가 <= 값.M고가)
		lib.F테스트_참임(t, 값.M시가 >= 값.M저가)
		lib.F테스트_참임(t, 값.M거래대금_백만 >= 0, 값.M종목코드, 값.M거래대금_백만)
		lib.F테스트_참임(t, 값.M전일_종가 >= 0)
		lib.F테스트_참임(t, 값.M상한가 >= 값.M고가)
		lib.F테스트_참임(t, 값.M우선_매도잔량 >= 0, 값.M종목코드, 값.M우선_매도잔량)
		lib.F테스트_참임(t, 값.M우선_매수잔량 >= 0, 값.M종목코드, 값.M우선_매수잔량)
		lib.F테스트_참임(t, 값.M총_매도잔량 >= 0, 값.M종목코드, 값.M총_매도잔량)
		lib.F테스트_참임(t, 값.M총_매수잔량 >= 0, 값.M종목코드, 값.M총_매수잔량)

		if 값.M누적_거래량 > 0 {
			lib.F테스트_참임(t, 값.M현재가 <= 값.M고가, 값.M종목코드, 값.M현재가, 값.M고가)
			lib.F테스트_참임(t, 값.M저가 >= 값.M하한가, 값.M종목코드, 값.M저가, 값.M하한가)

			lib.F테스트_참임(t, int64(lib.F오차(값.M현재가, 값.M전일_종가)) == 값.M전일종가대비등락폭,
				값.M종목코드, 값.M현재가, 값.M전일_종가, lib.F오차(값.M현재가, 값.M전일_종가), 값.M전일종가대비등락폭)

			예상_등락율 := float64(값.M현재가-값.M전일_종가) / float64(값.M전일_종가) * 100
			lib.F테스트_참임(t, lib.F오차(예상_등락율, 값.M전일종가대비등락율_퍼센트) < 1, 예상_등락율, 값.M전일종가대비등락율_퍼센트)

			lib.F테스트_참임(t, 값.M하한가 > 0)
		}

		if 값.M전일_종가 > 0 {
			switch 값.M전일종가대비구분 {
			case xt.P구분_상한:
				lib.F테스트_같음(t, 값.M현재가, 값.M상한가)
				lib.F테스트_같음(t, 값.M현재가, 값.M고가)
			case xt.P구분_상승:
				lib.F테스트_참임(t, 값.M현재가 > 값.M전일_종가, 값.M현재가, 값.M전일_종가)
			case xt.P구분_보합:
				lib.F테스트_참임(t, lib.F오차율_퍼센트(값.M현재가, 값.M전일_종가) < 5, 값.M종목코드, 값.M현재가, 값.M전일_종가)
			case xt.P구분_하락:
				lib.F테스트_참임(t, 값.M현재가 < 값.M전일_종가, 값.M현재가, 값.M전일_종가)
			case xt.P구분_하한:
				lib.F테스트_같음(t, 값.M현재가, 값.M하한가)
				lib.F테스트_같음(t, 값.M현재가, 값.M저가)
			}
		}
	}
}

func TestT8411_F현물_차트_분틱(t *testing.T) {
	t.Parallel()

	const 종목코드 = "069500" // 코덱스200
	var 이전_일자_시각 time.Time

	시작일자 := xing.F전일().AddDate(0, -1, 0)
	종료일자 := xing.F전일()

	값_모음, 에러 := xing.TrT8411_현물_차트_틱(종목코드, 시작일자, 종료일자, 3000)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, lib.F2일자(값.M일자_시각).Equal(시작일자) || lib.F2일자(값.M일자_시각).After(시작일자), 값.M일자_시각)
		lib.F테스트_참임(t, lib.F2일자(값.M일자_시각).Equal(종료일자) || lib.F2일자(값.M일자_시각).Before(종료일자), 값.M일자_시각)
		lib.F테스트_참임(t, 값.M일자_시각.After(이전_일자_시각) || 값.M일자_시각.Equal(이전_일자_시각))
		이전_일자_시각 = 값.M일자_시각

		F테스트_현물_차트_틱_응답_반복값_t8411(t, 값, 종목코드)
	}
}

func F테스트_현물_차트_틱_응답_반복값_t8411(t *testing.T, 값 *xt.T8411_현물_차트_틱_응답_반복값, 종목코드 string) {
	lib.F테스트_같음(t, 값.M종목코드, 종목코드)
	lib.F테스트_참임(t, 값.M일자_시각.Before(lib.F금일()))
	lib.F테스트_같음(t, 값.M시가, 값.M고가)
	lib.F테스트_같음(t, 값.M시가, 값.M저가)
	lib.F테스트_참임(t, 값.M시가 == 값.M종가, 값.M일자_시각, 값.M시가, 값.M종가)
	lib.F테스트_참임(t, 값.M거래량 > 0)
	lib.F테스트_에러없음(t, lib.F마지막_에러값(값.G수정구분_모음()))
}

func TestT8412_현물_차트_분(t *testing.T) {
	t.Parallel()

	const 종목코드 = "069500" // 코덱스200
	var 이전_일자_시각 time.Time

	전일 := xing.F전일()

	값_모음, 에러 := xing.TrT8412_현물_차트_분(종목코드, 전일, 전일, 3000)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_같음(t, lib.F2일자(값.M일자_시각), 전일, 값.M일자_시각.Format(lib.P일자_형식), 전일.Format(lib.P일자_형식))
		lib.F테스트_참임(t, 값.M일자_시각.After(이전_일자_시각) || 값.M일자_시각.Equal(이전_일자_시각))
		이전_일자_시각 = 값.M일자_시각

		F테스트_현물_차트_분_응답_반복값_t8412(t, 값, 종목코드)
	}
}

func F테스트_현물_차트_분_응답_반복값_t8412(t *testing.T, 값 *xt.T8412_현물_차트_분_응답_반복값, 종목코드 string) {
	lib.F테스트_같음(t, 값.M종목코드, 종목코드)
	lib.F테스트_참임(t, 값.M일자_시각.Before(lib.F금일()))
	lib.F테스트_같음(t, 값.M일자_시각.Second(), 0, 30)
	lib.F테스트_참임(t, 값.M고가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M종가)
	lib.F테스트_참임(t, 값.M저가 <= 값.M시가)
	lib.F테스트_참임(t, 값.M저가 <= 값.M종가)
	lib.F테스트_참임(t, 값.M거래량 >= 0, 값.M종목코드, 값.M일자_시각, 값.M거래량)
	lib.F테스트_참임(t, 값.M거래대금_백만 >= 0, 값.M일자_시각, 값.M거래량, 값.M거래대금_백만)
	lib.F테스트_에러없음(t, lib.F마지막_에러값(값.G수정구분_모음()))
	lib.F테스트_같음(t, 값.M종가등락구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
}

func TestT8413_현물_차트_일주월(t *testing.T) {
	t.Parallel()

	const 종목코드 = "069500" // 코덱스200
	var 이전_일자 time.Time

	당일 := xing.F당일()
	시작일 := 당일.AddDate(-1, 0, 0)

	값_모음, 에러 := xing.TrT8413_현물_차트_일주월(종목코드, 시작일, 당일, xt.P일주월_일, 2300)
	lib.F테스트_에러없음(t, 에러)

	for _, 값 := range 값_모음 {
		lib.F테스트_참임(t, 값.M일자.After(이전_일자) || 값.M일자.Equal(이전_일자))
		lib.F테스트_참임(t, 값.M일자.Equal(시작일) || 값.M일자.After(시작일), 값.M일자, 시작일)
		이전_일자 = 값.M일자

		F테스트_현물_차트_일주월_응답_반복값_t8413(t, 값, 종목코드)
	}
}

func F테스트_현물_차트_일주월_응답_반복값_t8413(t *testing.T, 값 *xt.T8413_현물_차트_일주월_응답_반복값, 종목코드 string) {
	lib.F테스트_같음(t, 값.M종목코드, 종목코드)
	lib.F테스트_참임(t, 값.M일자.Equal(lib.F금일()) || 값.M일자.Before(lib.F금일()))
	lib.F테스트_참임(t, 값.M고가 >= 값.M시가)
	lib.F테스트_참임(t, 값.M고가 >= 값.M종가)
	lib.F테스트_참임(t, 값.M저가 <= 값.M시가)
	lib.F테스트_참임(t, 값.M저가 <= 값.M종가)
	lib.F테스트_참임(t, 값.M거래량 >= 0, 값.M종목코드, 값.M일자, 값.M거래량)
	lib.F테스트_참임(t, 값.M거래대금_백만 >= 0, 값.M일자, 값.M거래량, 값.M거래대금_백만)
	//lib.F테스트_에러없음(t, lib.F마지막_에러값(값.G수정구분_모음()))	// 수정구분 해석에 에러가 많음.
	lib.F테스트_같음(t, 값.M종가등락구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)
}

func TestT8428_증시주변_자금_추이(t *testing.T) {
	t.Parallel()

	시장_구분 := ([]lib.T시장구분{lib.P시장구분_코스피, lib.P시장구분_코스닥})[lib.F임의_범위_이내_정수값(0, 1)]
	값_모음, 에러 := xing.TrT8428_증시주변자금추이(시장_구분, 500)
	lib.F테스트_에러없음(t, 에러)

	for i, 값 := range 값_모음 {
		lib.F테스트_참임(t, 값.M지수 > 0)
		lib.F테스트_같음(t, 값.M전일대비_구분, xt.P구분_상한, xt.P구분_상승, xt.P구분_보합, xt.P구분_하한, xt.P구분_하락)

		switch 값.M전일대비_구분 {
		case xt.P구분_상한, xt.P구분_상승:
			lib.F테스트_참임(t, 값.M전일대비_등락폭 > 0, 값.M일자, 값.M전일대비_구분, 값.M전일대비_등락폭, 값.M전일대비_등락율)
			lib.F테스트_참임(t, 값.M전일대비_등락율 >= 0, 값.M일자, 값.M전일대비_구분, 값.M전일대비_등락폭, 값.M전일대비_등락율)
		case xt.P구분_하한, xt.P구분_하락:
			lib.F테스트_참임(t, 값.M전일대비_등락폭 < 0, 값.M일자, 값.M전일대비_구분, 값.M전일대비_등락폭, 값.M전일대비_등락율)
			lib.F테스트_참임(t, 값.M전일대비_등락율 <= 0, 값.M일자, 값.M전일대비_구분, 값.M전일대비_등락폭, 값.M전일대비_등락율)
		}

		lib.F테스트_참임(t, 값.M거래량 >= 0)
		lib.F테스트_참임(t, 값.M고객예탁금_억 >= 0, 값.M고객예탁금_억)

		if i < (len(값_모음) - 1) {
			차이 := 값.M고객예탁금_억 - 값_모음[i+1].M고객예탁금_억
			lib.F테스트_참임(t, 차이*값.M예탁증감_억 >= 0, 차이, 값.M예탁증감_억)
		}

		lib.F테스트_참임(t, 값.M회전율 >= 0 || math.IsInf(값.M회전율, 1), 값.M회전율)
		lib.F테스트_참임(t, 값.M미수금_억 >= 0)
		lib.F테스트_참임(t, 값.M신용잔고_억 >= 0)
		lib.F테스트_참임(t, 값.M선물예수금_억 >= 0)
		lib.F테스트_참임(t, 값.M주식형_억 >= 0)
		lib.F테스트_참임(t, 값.M혼합형_주식_억 >= 0)
		lib.F테스트_참임(t, 값.M혼합형_채권_억 >= 0)
		lib.F테스트_참임(t, 값.M채권형_억 >= 0)
		lib.F테스트_참임(t, 값.MMF_억 >= 0)
	}
}

func TestT8436_주식종목_조회(t *testing.T) {
	t.Parallel()

	시장_구분 := ([]lib.T시장구분{lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥})[lib.F임의_범위_이내_정수값(0, 2)]

	값_모음, 에러 := xing.TrT8436_주식종목_조회(시장_구분)
	lib.F테스트_에러없음(t, 에러)
	lib.F테스트_참임(t, len(값_모음) > 0, len(값_모음))

	for _, 응답값 := range 값_모음 {
		종목, 에러 := xing.F종목by코드(응답값.M종목코드)
		lib.F테스트_에러없음(t, 에러)

		인덱스 := lib.F최소값_정수(len(응답값.M종목명), len(종목.G이름()))
		lib.F테스트_같음(t, 응답값.M종목명[:인덱스], 종목.G이름()[:인덱스])

		switch 응답값.M시장구분 {
		case lib.P시장구분_ETF:
			lib.F테스트_다름(t, 응답값.M증권그룹, xt.P증권그룹_주식)
			lib.F테스트_같음(t, 응답값.M증권그룹, xt.P증권그룹_상장지수펀드_ETF, xt.P증권그룹_해외ETF)
		case lib.P시장구분_ETN:
			lib.F테스트_다름(t, 응답값.M증권그룹, xt.P증권그룹_주식)
			lib.F테스트_같음(t, 응답값.M증권그룹, xt.P증권그룹_ETN)
		case lib.P시장구분_코스피, lib.P시장구분_코스닥:
			// 다음넷의 ETF종목정보가 불완전해서 주식만 테스트 함.
			lib.F테스트_같음(t, 응답값.M시장구분, 종목.G시장구분())
		}

		if 응답값.M증권그룹 == xt.P증권그룹_주식 {
			lib.F테스트_같음(t, 응답값.M시장구분, lib.P시장구분_전체, lib.P시장구분_코스피, lib.P시장구분_코스닥)
		}

		lib.F테스트_같음(t, 응답값.M주문수량단위, 1)

		// 상한가 예상값 계산에 예외가 너무 많아서 건너뜀.
		//호가단위, 에러 := lib.F최소_호가단위by시장구분_기준가(종목.G시장구분(), 응답값.M전일가)
		//lib.F테스트_에러없음(t, 에러)
		//예상값_상한가 := int64(float64(응답값.M전일가) * 1.3)
		//오차_상한가 := lib.F2절대값_정수64(응답값.M상한가 - 예상값_상한가)
		//오차율_상한가 := float64(오차_상한가) / float64(응답값.M상한가) * 100
		//lib.F테스트_참임(t,  오차_상한가 <= 호가단위 || 오차율_상한가 < 3,
		//	응답값.M종목코드, 응답값.M상한가, 예상값_상한가, 오차_상한가, 호가단위, 오차율_상한가)

		// 액면분할 하면 전일가가 상한가보다 높아짐.
		//lib.F테스트_참임(t, 응답값.M상한가 == 0 || 응답값.M상한가 > 응답값.M전일가, 응답값.M상한가, 응답값.M전일가)
		lib.F테스트_참임(t, 응답값.M상한가 == 0 || 응답값.M상한가 > 응답값.M하한가, 응답값.M상한가, 응답값.M하한가)
		lib.F테스트_참임(t, 응답값.M상한가 == 0 || 응답값.M상한가 > 응답값.M기준가, 응답값.M상한가, 응답값.M기준가)

		// 하한가 예상값 계산의 예외가 너무 많아서 건너뜀.
		//예상값_하한가 := int64(float64(응답값.M전일가) * 0.7)
		//오차_하한가 := lib.F2절대값_정수64(응답값.M하한가 - 예상값_하한가)
		//오차율_하한가 := float64(오차_하한가) / float64(응답값.M하한가) * 100
		//lib.F테스트_참임(t, 오차_하한가 <= 호가단위 || 오차율_하한가 < 3,
		//	응답값.M종목코드, 응답값.M하한가, 예상값_하한가, 오차_하한가, 호가단위, 오차율_하한가)

		// 액면분할 하면 전일가가 하한가보다 높아짐.
		//lib.F테스트_참임(t, 응답값.M전일가 == 0 || 응답값.M하한가 <= 응답값.M전일가, 응답값.M종목코드, 응답값.M하한가, 응답값.M전일가)
		lib.F테스트_참임(t, 응답값.M하한가 == 0 || 응답값.M하한가 <= 응답값.M기준가, 응답값.M종목코드, 응답값.M하한가, 응답값.M기준가)
		lib.F테스트_같음(t, 응답값.M증권그룹, xt.P증권그룹_주식, xt.P증권그룹_예탁증서,
			xt.P증권그룹_증권투자회사_뮤추얼펀드, xt.P증권그룹_Reits종목, xt.P증권그룹_상장지수펀드_ETF,
			xt.P증권그룹_선박투자회사, xt.P증권그룹_인프라투융자회사, xt.P증권그룹_해외ETF,
			xt.P증권그룹_해외원주, xt.P증권그룹_ETN)
	}
}
